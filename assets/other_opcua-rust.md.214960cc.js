import{_ as a,c as s,o as e,N as n}from"./chunks/framework.3a9190c5.js";const m=JSON.parse('{"title":"opcua Rust版本学习-client","description":"","frontmatter":{"title":"opcua Rust版本学习-client","date":"2020-10-20T09:48:12.000Z","draft":false,"markup":"mmark"},"headers":[],"relativePath":"other/opcua-rust.md"}'),l={name:"other/opcua-rust.md"},i=n(`<h2 id="一个client对应多少线程-任务" tabindex="-1">一个client对应多少线程/任务 <a class="header-anchor" href="#一个client对应多少线程-任务" aria-label="Permalink to &quot;一个client对应多少线程/任务&quot;">​</a></h2><p>这里面有tokio 异步任务,所以只要是异步执行的,都任务是独立的. 一个client至少会对应两个独立线程(不包含tokio创建的线程).</p><h3 id="session-中的任务" tabindex="-1">session 中的任务 <a class="header-anchor" href="#session-中的任务" aria-label="Permalink to &quot;session 中的任务&quot;">​</a></h3><h4 id="async-responses" tabindex="-1">async responses <a class="header-anchor" href="#async-responses" aria-label="Permalink to &quot;async responses&quot;">​</a></h4><p>一个client对应一个session,一个session 有一个后台线程 <code> thread::spawn(move || Self::run_loop(session, Self::POLL_SLEEP_INTERVAL, rx));</code> 周期性的去从message_queue中读取async_responses.</p><ol><li>ServiceFault 错误通知</li><li>PublishResponse 订阅拉的结果,这些结果会通过<code>OnSubscriptionNotification</code> 告诉客户端使用者.</li></ol><p>这个线程的轮询周期是10ms.</p><h4 id="session-activity-task" tabindex="-1">session_activity_task <a class="header-anchor" href="#session-activity-task" aria-label="Permalink to &quot;session_activity_task&quot;">​</a></h4><p>通过发送一个空的ReadRequest来模拟ping消息,保持和服务器的连接. 这是一个tokio任务,周期是1秒钟.</p><h3 id="tcp-transport" tabindex="-1">tcp transport <a class="header-anchor" href="#tcp-transport" aria-label="Permalink to &quot;tcp transport&quot;">​</a></h3><p>tcp连接处理相关.</p><h4 id="_1-总任务" tabindex="-1">1. 总任务 <a class="header-anchor" href="#_1-总任务" aria-label="Permalink to &quot;1. 总任务&quot;">​</a></h4><p>建立连接,send hello以后就老等下面三个任务(都在<code>connection_task</code>中)完成后结束. 注意这是一个独立的线程.</p><h4 id="_2-spawn-finished-monitor-task" tabindex="-1">2. spawn_finished_monitor_task <a class="header-anchor" href="#_2-spawn-finished-monitor-task" aria-label="Permalink to &quot;2. spawn_finished_monitor_task&quot;">​</a></h4><p>监控连接是否结束,这个很奇怪,没有使用通知,居然是轮训模式 轮询周期是200ms</p><h4 id="_3-spawn-reading-task" tabindex="-1">3. spawn_reading_task <a class="header-anchor" href="#_3-spawn-reading-task" aria-label="Permalink to &quot;3. spawn_reading_task&quot;">​</a></h4><p>从tcp连接上读取服务器发送过来的消息,消息主要有三种类型:</p><ol><li>Ack 对Hello消息的确认,其他消息都是Request/Reponse?</li><li>Error</li><li>Response</li></ol><p>Server从不主动给client发消息,除了Error以外.</p><p>收到Response以后,放到message_queue的<code>responses</code>中.等待其他任务来取.</p><h4 id="_4-spawn-writing-task" tabindex="-1">4. spawn_writing_task <a class="header-anchor" href="#_4-spawn-writing-task" aria-label="Permalink to &quot;4. spawn_writing_task&quot;">​</a></h4><p>通过message_queue中的request_channel接受请求,然后发送给服务器.</p><h3 id="subscription相关" tabindex="-1">subscription相关 <a class="header-anchor" href="#subscription相关" aria-label="Permalink to &quot;subscription相关&quot;">​</a></h3><p>一个client只有一个session,但是一个session可以有多个subscription,每个subscription有一个唯一的整数id.</p><h4 id="_1-timer-task" tabindex="-1">1. timer_task <a class="header-anchor" href="#_1-timer-task" aria-label="Permalink to &quot;1. timer_task&quot;">​</a></h4><p>周期性的向服务器发送<code>PublishRequest</code>,不管服务器有没有响应. 除非收到了服务器的ServiceFault(BadTooManyPublishRequests).</p><h3 id="主线程" tabindex="-1">主线程 <a class="header-anchor" href="#主线程" aria-label="Permalink to &quot;主线程&quot;">​</a></h3><p>send_request是一个同步的操作.</p><ol><li>通过async方式将request放入message_queue的队列中</li><li>不停的轮询message_queue的response中是否有想要的响应</li><li>拿到响应后返回.</li></ol><p>这里有一个问题,就是将request放入message_queue中会锁住session_state,但是这个数据结构非常关键. 到处都在用,是否会造成死锁? 如果一个请求迟迟发送不出去呢? 即使这时候收到了服务器端的其他publish Response消息,也是无法处理的,因为处理的过程要锁住session_state.</p><h2 id="server-端统计" tabindex="-1">Server 端统计 <a class="header-anchor" href="#server-端统计" aria-label="Permalink to &quot;Server 端统计&quot;">​</a></h2><h3 id="http-server" tabindex="-1">http server <a class="header-anchor" href="#http-server" aria-label="Permalink to &quot;http server&quot;">​</a></h3><p>这是一个通过http接口展示server内部统计信息的工具. 比较独立,可以不用管,需要的时候才会启动.</p><h3 id="pollingaction" tabindex="-1">PollingAction <a class="header-anchor" href="#pollingaction" aria-label="Permalink to &quot;PollingAction&quot;">​</a></h3><p>一个定时执行函数的工具,只不过他会检查server是否在运行.</p><h3 id="tcp-transport-1" tabindex="-1">tcp_transport <a class="header-anchor" href="#tcp-transport-1" aria-label="Permalink to &quot;tcp_transport&quot;">​</a></h3><p>和客户端通过tcp进行通信的地方, 以下任务是每一个连接都要创建的.</p><h4 id="spawn-hello-timeout-task" tabindex="-1">spawn_hello_timeout_task <a class="header-anchor" href="#spawn-hello-timeout-task" aria-label="Permalink to &quot;spawn_hello_timeout_task&quot;">​</a></h4><p>检查连接建立后,是否收到hello,如果收到呢就结束这个task,否则后台一直周期性的检查.</p><ol><li>超时, 发送Message::Quit,断开连接</li><li>收到,结束.</li></ol><h4 id="spawn-subscriptions-task" tabindex="-1">spawn_subscriptions_task <a class="header-anchor" href="#spawn-subscriptions-task" aria-label="Permalink to &quot;spawn_subscriptions_task&quot;">​</a></h4><p>周期性的,这个周期取决于采样周期和订阅周期. 两个任务:</p><h5 id="收集pulish-responses" tabindex="-1">收集pulish responses <a class="header-anchor" href="#收集pulish-responses" aria-label="Permalink to &quot;收集pulish responses&quot;">​</a></h5><ol><li>清理过期的publish requests</li><li>收集publish responses,并通过channel 发送.</li></ol><h5 id="接收publish-reponses" tabindex="-1">接收publish reponses <a class="header-anchor" href="#接收publish-reponses" aria-label="Permalink to &quot;接收publish reponses&quot;">​</a></h5><p>收到以后通过sender发送出去</p><p>我的问题: *<strong>为什么这是两个独立的任务? 合成一个不更好么?</strong></p><h4 id="spawn-finished-monitor-task" tabindex="-1">spawn_finished_monitor_task <a class="header-anchor" href="#spawn-finished-monitor-task" aria-label="Permalink to &quot;spawn_finished_monitor_task&quot;">​</a></h4><p>一个独立的任务,周期性检查server是否退出. 思路和client是完全一样的. 感觉这种周期性的任务很奇怪,也不合理.</p><h4 id="spawn-reading-loop-task" tabindex="-1">spawn_reading_loop_task <a class="header-anchor" href="#spawn-reading-loop-task" aria-label="Permalink to &quot;spawn_reading_loop_task&quot;">​</a></h4><p>读取来自客户端的消息,这里面主要有两个状态:</p><ol><li><p>WaitingHello 这个时候什么消息都不处理,只处理Hello,处理以后,才能正常处理其他消息.</p></li><li><p>ProcessMessages 处理任何消息.核心在process_chunk中.</p></li></ol><p>其他的就是如何处理错误以及结束.</p><h4 id="spawn-writing-loop-task" tabindex="-1">spawn_writing_loop_task <a class="header-anchor" href="#spawn-writing-loop-task" aria-label="Permalink to &quot;spawn_writing_loop_task&quot;">​</a></h4><p>向客户端发送消息,发送消息的请求来自以上三个task:</p><ul><li>spawn_hello_timeout_task</li><li>spawn_subscriptions_task</li><li>spawn_reading_loop_task</li></ul><ol><li>发送之前检查连接的可用性</li><li>发送之前检查消息的正确性</li><li>将要发送消息放入buffer中.</li><li>通过write_bytes_task发送出去</li><li>发送后再次检查是否需要关闭.</li></ol><p>** shutdown没有await,需要加上.</p><h3 id="server-层的task" tabindex="-1">Server 层的task <a class="header-anchor" href="#server-层的task" aria-label="Permalink to &quot;Server 层的task&quot;">​</a></h3><h4 id="discovery-server相关" tabindex="-1">discovery server相关 <a class="header-anchor" href="#discovery-server相关" aria-label="Permalink to &quot;discovery server相关&quot;">​</a></h4><p>可以不用,暂时忽略.</p><h4 id="add-polling-action" tabindex="-1">add_polling_action <a class="header-anchor" href="#add-polling-action" aria-label="Permalink to &quot;add_polling_action&quot;">​</a></h4><p>这是一个pub api,让调用者可以周期性的在server内部做一些事情.</p><p>但是这个只能添加,不能删除.</p><h2 id="交叉编译" tabindex="-1">交叉编译 <a class="header-anchor" href="#交叉编译" aria-label="Permalink to &quot;交叉编译&quot;">​</a></h2><p>针对raspberry进行交叉编译</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">sudo apt-get install gcc-arm-linux-gnueabihf</span></span>
<span class="line"><span style="color:#A6ACCD;">rustup target add armv7-unknown-linux-gnueabihf     # armv7</span></span>
<span class="line"><span style="color:#A6ACCD;">cargo build --target armv7-unknown-linux-gnueabihf --release </span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="cargo-config" tabindex="-1">.cargo/config <a class="header-anchor" href="#cargo-config" aria-label="Permalink to &quot;.cargo/config&quot;">​</a></h4><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">[target.arm-unknown-linux-musleabihf]</span></span>
<span class="line"><span style="color:#A6ACCD;">linker = &quot;arm-linux-musleabihf-ld&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">[target.armv7-unknown-linux-musleabihf]</span></span>
<span class="line"><span style="color:#A6ACCD;">linker = &quot;arm-linux-musleabihf-ld&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">[target.arm-unknown-linux-gnueabihf]</span></span>
<span class="line"><span style="color:#A6ACCD;">linker = &quot;arm-linux-gnueabihf-gcc&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">[target.armv7-unknown-linux-gnueabihf]</span></span>
<span class="line"><span style="color:#A6ACCD;">linker = &quot;arm-linux-gnueabihf-gcc&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="openssl-依赖问题" tabindex="-1">openssl 依赖问题 <a class="header-anchor" href="#openssl-依赖问题" aria-label="Permalink to &quot;openssl 依赖问题&quot;">​</a></h3><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">cd /tmp</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">wget https://www.openssl.org/source/openssl-1.0.1t.tar.gz</span></span>
<span class="line"><span style="color:#A6ACCD;">tar xzf openssl-1.0.1t.tar.gz</span></span>
<span class="line"><span style="color:#A6ACCD;">export MACHINE=armv7</span></span>
<span class="line"><span style="color:#A6ACCD;">export ARCH=arm</span></span>
<span class="line"><span style="color:#A6ACCD;">export CC=arm-linux-musleabi-gcc</span></span>
<span class="line"><span style="color:#A6ACCD;">cd openssl-1.0.1t &amp;&amp; ./config shared &amp;&amp; make &amp;&amp; cd -</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">export OPENSSL_LIB_DIR=~/openssl-1.0.1t/</span></span>
<span class="line"><span style="color:#A6ACCD;">export OPENSSL_INCLUDE_DIR=~/openssl-1.0.1t/include</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果想静态编译就要使用arm-linux-musleabi-gcc, 用arm-linux-musleabihf-gcc的话,会出现<code>-mfloat-abi=hard</code>不支持错误.</p>`,72),r=[i];function t(o,p,c,u,h,d){return e(),s("div",null,r)}const _=a(l,[["render",t]]);export{m as __pageData,_ as default};
