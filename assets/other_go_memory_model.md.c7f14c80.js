import{_ as s,c as a,o as n,N as l}from"./chunks/framework.3a9190c5.js";const C=JSON.parse('{"title":"go语言的内存模型","description":"","frontmatter":{"title":"go语言的内存模型","date":"2022-05-30T03:06:23.000Z","draft":false},"headers":[],"relativePath":"other/go_memory_model.md"}'),e={name:"other/go_memory_model.md"},p=l(`<h2 id="tcmalloc" tabindex="-1">TCMalloc <a class="header-anchor" href="#tcmalloc" aria-label="Permalink to &quot;TCMalloc&quot;">​</a></h2><p>TCMalloc是golang的内存分配算法,这个是用来替代malloc的内存分配函数,他可以减少内存碎片,更适用于多核,并行性更友好.</p><ul><li>TCMalloc用固定大小的page(页)来执行内存获取、分配等操作。这个特性跟Linux物理内存页的划分是不是有同样的道理。</li><li>TCMalloc用固定大小的对象，比如8KB，16KB 等用于特定大小对象的内存分配，这对于内存获取或释放等操作都带来了简化的作用。</li><li>TCMalloc还利用缓存常用对象来提高获取内存的速度。</li><li>TCMalloc还可以基于每个线程或者每个CPU来设置缓存大小</li><li>TCMalloc基于每个线程独立设置缓存分配策略，减少了多线程之间锁的竞争。</li><li></li></ul><p><img alt="img" data-src="assets/tcmalloc_arch.png" loading="lazy" class="lazy"></p><p>架构的目的是应对复杂性,让复杂的代码在性能几乎不变的情况下,可维护性,可测试性等大幅提升.</p><p>这里简单对比一下JVM中的对象管理,采用的是新生代和老年代.</p><h3 id="主要概念" tabindex="-1">主要概念 <a class="header-anchor" href="#主要概念" aria-label="Permalink to &quot;主要概念&quot;">​</a></h3><ol><li><p>Page</p><p>内核中的内存管理单位</p></li><li><p>Span</p><p>PageHeap中的内存管理单位</p></li><li><p>ThreadCache</p><p>线程各自独立的cache,主要是管理小对象的分配</p></li><li><p>CentralCache</p><p>pageHeap和Threadcache的内存中转站,结构与Threadcache类似. 当Threadcache内存不足时从centralcache获取,过多的时候,放回centralcache.</p></li><li><p>PageHeap</p><p>保存对象是Span</p><h2 id="pprof-使用" tabindex="-1">pprof 使用 <a class="header-anchor" href="#pprof-使用" aria-label="Permalink to &quot;pprof 使用&quot;">​</a></h2><p>在tcmalloc的基础知识之后,来看怎么使用这些知识.</p><p>核心指标:</p><ul><li><p>采样周期</p><ul><li>通过GODEBUG的memprofilerate来修改,越低越准确,性能损耗自然越大</li></ul></li><li><p>内存碎片率</p><ul><li>内存碎片主要来自于内部, gap预期12.5%左右</li></ul><h3 id="主要数据解读" tabindex="-1">主要数据解读 <a class="header-anchor" href="#主要数据解读" aria-label="Permalink to &quot;主要数据解读&quot;">​</a></h3><p><img alt="图片" data-src="assets/go_memstats.png" loading="lazy" class="lazy"></p><p>一个memstat样例:</p></li></ul><div class="language-txt line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">sys_bytes 1.6808429272e+10    // 16029  // 系统常驻内存，单位是 M</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">alloc_bytes 1.0527689648e+10  // 10040  // 分配出的对象，且使用的</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">heap_alloc_bytes 1.0527689648e+10  // 10040  // 堆上分配出来，且在使用的</span></span>
<span class="line"><span style="color:#A6ACCD;">heap_idle_bytes 4.272185344e+09  // 4074  // 堆上的内存，但是还没人用，等待被使用</span></span>
<span class="line"><span style="color:#A6ACCD;">heap_inuse_bytes 1.154125824e+10  // 11006  // 堆内存，且在使用的</span></span>
<span class="line"><span style="color:#A6ACCD;">heap_released_bytes 5.06535936e+08  // 483   // 释放给 os 的堆内存</span></span>
<span class="line"><span style="color:#A6ACCD;">heap_sys_bytes 1.5813443584e+10  // 15080.8  // 系统占用内存</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">stack_inuse_bytes 2.424832e+07   // 23   // 栈上的内存</span></span>
<span class="line"><span style="color:#A6ACCD;">stack_sys_bytes 2.424832e+07   // 23    // 栈上的内存</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">mcache_inuse_bytes 55552    // 0.05  // mcache 结构的内存占用</span></span>
<span class="line"><span style="color:#A6ACCD;">mcache_sys_bytes 65536     // 0.06  // mcache 结构的内存占用</span></span>
<span class="line"><span style="color:#A6ACCD;">mspan_inuse_bytes 1.87557464e+08  // 178.8  // mspan 结构的内存占用</span></span>
<span class="line"><span style="color:#A6ACCD;">mspan_sys_bytes 2.31292928e+08   // 220.5  // mspan 结构的内存占用</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">gc_sys_bytes 6.82119168e+08   // 650  // gc 的元数据</span></span>
<span class="line"><span style="color:#A6ACCD;">buck_hash_sys_bytes 3.86714e+06  // 3.6   // bucket hash 表的开销</span></span>
<span class="line"><span style="color:#A6ACCD;">other_sys_bytes 5.3392596e+07   // 50   // 用于其他的系统分配出来的内存</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">next_gc_bytes 1.4926500032e+10   // 14235  // 下一次 gc 的目标内存大小</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div></li></ol><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><p><a href="https://www.cnblogs.com/jiujuan/p/13869547.html#:~:text=tcmalloc%E4%B9%9F%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%A1%B5%E7%9A%84,%E9%A1%B5%E5%A4%A7%E5%B0%8F%E7%9A%842%E5%80%8D%E3%80%82" target="_blank" rel="noreferrer">TCMalloc 内存分配原理简析 - 九卷 - 博客园 (cnblogs.com)</a></p><p><a href="https://mp.weixin.qq.com/s/ZuGhaiDlvAd2waOj6CMgqg" target="_blank" rel="noreferrer">Go 最细节篇｜pprof 统计的内存总是偏小？ (qq.com)</a></p>`,11),c=[p];function r(o,t,i,b,m,_){return n(),a("div",null,c)}const u=s(e,[["render",r]]);export{C as __pageData,u as default};
