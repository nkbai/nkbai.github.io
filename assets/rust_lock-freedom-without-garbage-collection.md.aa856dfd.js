import{o as n,c as s,e as a}from"./app.d382aac0.js";const p='{"title":"Rust无锁编程","description":"","frontmatter":{"title":"Rust无锁编程","date":"2020-03-16T03:57:03.000Z","draft":false,"tags":["rust","lock-free","GC"],"categories":["技术相关"]},"headers":[{"level":2,"title":"Benchmarks","slug":"benchmarks"},{"level":3,"title":"分析","slug":"分析"},{"level":2,"title":"无锁数据结构","slug":"无锁数据结构"},{"level":3,"title":"特雷伯栈","slug":"特雷伯栈"},{"level":3,"title":"The problem","slug":"the-problem"},{"level":2,"title":"基于epoch的内存回收","slug":"基于epoch的内存回收"},{"level":2,"title":"The Rust API","slug":"the-rust-api"},{"level":3,"title":"Guard","slug":"guard"},{"level":3,"title":"Owned and Shared pointers","slug":"owned-and-shared-pointers"},{"level":3,"title":"Atomic","slug":"atomic"},{"level":2,"title":"展望","slug":"展望"},{"level":2,"title":"我的一些心得","slug":"我的一些心得"}],"relativePath":"rust/lock-freedom-without-garbage-collection.md","lastUpdated":1643457011867}',e={},t=[a('<ul><li><a href="#benchmarks">Benchmarks</a><ul><li><a href="#%e5%88%86%e6%9e%90">分析</a></li></ul></li><li><a href="#%e6%97%a0%e9%94%81%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">无锁数据结构</a><ul><li><a href="#%e7%89%b9%e9%9b%b7%e4%bc%af%e6%a0%88">特雷伯栈</a></li><li><a href="#the-problem">The problem</a></li></ul></li><li><a href="#%e5%9f%ba%e4%ba%8eepoch%e7%9a%84%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6">基于epoch的内存回收</a></li><li><a href="#the-rust-api">The Rust API</a><ul><li><a href="#guard">Guard</a></li><li><a href="#owned-and-shared-pointers">Owned and Shared pointers</a><ul><li><a href="#owned">Owned</a></li><li><a href="#shared">Shared</a></li></ul></li><li><a href="#atomic">Atomic</a><ul><li><a href="#loading">Loading</a></li><li><a href="#store">store</a></li><li><a href="#cas">CAS</a></li><li><a href="#%e9%87%8a%e6%94%be%e5%86%85%e5%ad%98">释放内存</a></li><li><a href="#%e5%9f%ba%e4%ba%8eepoch%e7%9a%84%e7%89%b9%e9%9b%b7%e8%b4%9d%e5%b0%94%e6%a0%88">基于epoch的特雷贝尔栈</a></li><li><a href="#%e7%ae%a1%e7%90%86%e5%9e%83%e5%9c%be">管理垃圾</a></li></ul></li></ul></li><li><a href="#%e5%b1%95%e6%9c%9b">展望</a></li><li><a href="#%e6%88%91%e7%9a%84%e4%b8%80%e4%ba%9b%e5%bf%83%e5%be%97">我的一些心得</a></li></ul><p>本文内容译自<a href="http://aturon.github.io/tech/2015/08/27/epoch/" target="_blank" rel="noopener noreferrer">Lock-freedom without garbage collection</a>,中间有少量自己的修改.</p><p>人们普遍认为，垃圾收集的一个优点是易于构建高性能的无锁数据结构。 对这些数据结构进行手动内存管理并不容易，而 GC 使其变得非常简单。 这篇文章表明，使用 Rust，可以为并发数据结构构建一个内存管理 API:</p><ul><li>使得实现无锁数据结构和 有GC的语言(如Java) 一样容易;</li><li>静态保护以防止内存管理方案的滥用;</li><li>具有与 GC 竞争的开销(并且比 GC 更可预测) 在下面展示的基准测试中，Rust 能够轻松地击败 Java 无锁队列实现，并且具有易于编写的实现。</li></ul><p>我已经在<a href="https://github.com/aturon/crossbeam" target="_blank" rel="noopener noreferrer">Crossbeam</a> 这个crate中实现了“基于epoch的内存回收” ，这个crate现在就可以用于您自己的数据结构。 本文介绍了一些关于无锁数据结构的背景知识、 epoch 算法以及完整的Rust API。</p><h2 id="benchmarks"><a class="header-anchor" href="#benchmarks" aria-hidden="true">#</a> Benchmarks</h2><p>在深入研究基于epoch的内存回收的API设计和使用之前，让我们直奔主题: 性能。</p><p>为了测试 Crossbeam 实现相对于完整 GC(有完整GC的语言,比如java) 的开销，我在它上面实现了一个基本的无锁队列(<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener noreferrer">Michael Scott queue</a>) ，并在 Scala 中构建了相同的队列。 一般来说，基于 jvm 的语言是通向无锁数据结构的“良好 GC”路径的一个很好的测试用例。</p><p>除了上述实现,我还比较了:</p><ul><li>基于crossbeam实现的更高效的分段队列(segmented queue),它分配具有多个slot的节点</li><li>使用锁保护的单线程队列</li><li>使用java.util.concurrent实现的ConcurrentLinkedQueue,他是<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener noreferrer">Michael Scott queue</a>一个优化版本.</li></ul><p>我使用了两种方式来测试这些队列:</p><ul><li>MPSC 一个多生产者、单消费者(MPSC)场景，其中两个线程重复发送消息，一个线程接收消息，两者都在一个循环中。</li><li>MPMC 多生产者、多消费者(multi-producer，multi-consumer，MPMC)场景，其中两个线程发送和两个线程接收在一个循环中。</li></ul><p>这样的基准测试对于测量“竞争”(多线程竞争同时进行并发更新)下无锁数据结构的可伸缩性相当典型。 在构建生产队列实现时，应该对许多变体进行基准测试; 这里的目标仅仅是评估内存管理方案的大致开销。</p><p>对于 MPSC 测试，我还将其与 Rust 内置channel中使用的算法进行了比较，该算法针对此场景进行了优化(因此不支持 MPMC)。</p><p>测试的机器是4 Core 2.6 Ghz Intel Core i 7,16gb 内存。 以下是以纳秒为单位给出的结果(越低越好)</p><p><img alt="" data-src="img/bench-mpsc.png" loading="lazy" class="lazy"><img alt="" data-src="img/bench-mpmc.png" loading="lazy" class="lazy"></p><h3 id="分析"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h3><p>主要的收获是，Crossbeam 的实现方式(尚未调整)在所有情况下都具有竞争力。 通过使用更聪明或更专业的队列，可以在 Rust 和 JVM 两方面都做得更好，但这些结果至少表明 epoch 的开销是合理的。</p><p>注意，java / scala 版本在 MPMC 测试中的表现要比在 MPSC 测试中好得多。 为什么？ 答案很简单: 垃圾收集。 在 MPSC 测试中，随着时间的推移，生产者往往会超过消费者，这意味着队列中的数据量会缓慢增长。 这反过来又增加了每次垃圾收集的成本，这涉及到遍历实时数据集。</p><p>相比之下，在 epoch 方案中，管理垃圾的成本是相对固定的: 它与线程的数量成正比，而不是与活动数据的数量成正比。 事实证明，这会带来更好、更一致 / 更可预测的性能。</p><p>最后，我没有在图表中包括的一个比较(因为它会使其他比较相形见绌)是在 Rust 中围绕 deque 使用 Mutex。 对于 MPMC 测试，性能约为3040ns/op，比 Crossbeam 实现慢20倍以上。 这生动地说明了为什么无锁数据结构非常重要——那么让我们开始深入了解它们是什么。</p><h2 id="无锁数据结构"><a class="header-anchor" href="#无锁数据结构" aria-hidden="true">#</a> 无锁数据结构</h2><p>当您希望使用(和变更)来自许多并发线程的数据结构时，需要进行同步。 最简单的解决方案是全局锁定 Rust，将整个数据结构包装在一个 Mutex 中。</p><p>问题是，这种“粗粒度”同步意味着在访问数据结构时，多个线程总是需要协调，即使它们访问的是不相交的数据结构部分。 这还意味着，即使一个线程只是尝试读取，它也必须通过更新锁状态进行写操作——由于锁是一个全局通信点，这些写操作将导致大量缓存失效通信。 即使对于更精细的内容使用了大量的锁，仍然存在其他危险，如<a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener noreferrer">死锁</a>和<a href="https://en.wikipedia.org/wiki/Priority_inversion" target="_blank" rel="noopener noreferrer">优先转置</a>，并且通常仍然将性能提升有限(you often still leave performance on the table.)</p><p>一个更加激进的替代方案是无锁数据结构，它使用原子操作直接更改数据结构，而不需要进一步同步。 它们通常比基于锁的设计更快、更可伸缩、更健壮。</p><p>在这篇文章中，我不打算给出一个完整的无锁编程教程，但是关键的一点是，如果你没有全局同步，那么很难说你什么时候可以释放内存。 许多已发布的算法基本上假定是垃圾回收器或其他回收内存的方法。 因此，在Rust中实现无锁并发之前，我们需要一个关于内存回收的工具——这就是这篇博客文章的目的所在。</p><h3 id="特雷伯栈"><a class="header-anchor" href="#特雷伯栈" aria-hidden="true">#</a> 特雷伯栈</h3><p>为了让事情更具体，让我们看看无锁数据结构的“ Hello world” : 特雷伯栈(Treiber’s stack)。 栈表示为单链表，所有修改都发生在head这个指针上:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token attribute attr-name">#![feature(box_raw)]</span>\n\n<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ptr<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token keyword">self</span><span class="token punctuation">,</span> null_mut<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>sync<span class="token punctuation">::</span>atomic<span class="token punctuation">::</span></span><span class="token class-name">AtomicPtr</span><span class="token punctuation">;</span>\n<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>sync<span class="token punctuation">::</span>atomic<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Relaxed</span><span class="token punctuation">,</span> <span class="token class-name">Release</span><span class="token punctuation">,</span> <span class="token class-name">Acquire</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    head<span class="token punctuation">:</span> <span class="token class-name">AtomicPtr</span><span class="token operator">&lt;</span><span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">struct</span> <span class="token type-definition class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    data<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>\n    next<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Stack</span> <span class="token punctuation">{</span>\n            head<span class="token punctuation">:</span> <span class="token class-name">AtomicPtr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">null_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>最简单的方法就是从pop开始。 要pop，你只需要循环保存栈顶指针head，然后做一个CAS，用next指针替换当前head:</p><p>请注意，如果旧值匹配，则 compare_and_swap 原子性地将AtomicPtr的值从旧值更改为新值。 同时，如果你不熟悉Acquire, Release和Relaxed 这些标签的含义，你可以放心地忽略它们。</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">loop</span> <span class="token punctuation">{</span>\n            <span class="token comment">// take a snapshot</span>\n            <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Acquire</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// we observed the stack empty</span>\n            <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token function">null_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span> <span class="token class-name">None</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token keyword">let</span> next <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// if snapshot is still good, update from `head` to `next`</span>\n                <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token class-name">Release</span><span class="token punctuation">)</span> <span class="token operator">==</span> head <span class="token punctuation">{</span>\n\n                    <span class="token comment">// extract out the data from the now-unlinked node</span>\n                    <span class="token comment">// **NOTE**: leaks the node!</span>\n                    <span class="token keyword">return</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token namespace">ptr<span class="token punctuation">::</span></span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><code>ptr::read</code> 函数是 Rust 在没有静态或动态跟踪的情况下提取数据所有权的方法。 在这里，我们使用 <code>compare_and_swap</code> 的原子性来保证只有一个线程会调用 <code>ptr::read</code>-正如我们将看到的，这个实现永远不会释放 Nodes，因此数据上的析构函数永远不会被调用。 这两个事实一起使我们使用<code>ptr::read</code>是安全的。</p><p>push 和pop差不多:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// allocate the node, and immediately turn it into a *mut pointer</span>\n        <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">into_raw</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Node</span> <span class="token punctuation">{</span>\n            data<span class="token punctuation">:</span> t<span class="token punctuation">,</span>\n            next<span class="token punctuation">:</span> <span class="token function">null_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">loop</span> <span class="token punctuation">{</span>\n            <span class="token comment">// snapshot current head</span>\n            <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Relaxed</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// update `next` pointer with snapshot</span>\n            <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token punctuation">}</span>\n\n            <span class="token comment">// if snapshot is still good, link in new node</span>\n            <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token class-name">Release</span><span class="token punctuation">)</span> <span class="token operator">==</span> head <span class="token punctuation">{</span>\n                <span class="token keyword">break</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="the-problem"><a class="header-anchor" href="#the-problem" aria-hidden="true">#</a> The problem</h3><p>如果是支持GC的语言编写了上面的代码,那么我们已经实现了一个lock-free stack,但是在rust中不行,因为它发生了内存泄漏.特别是，当Node指针从堆栈中移除后，pop实现不会尝试释放它。</p><p>如果我们加上内存释放会有什么问题呢:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token comment">// extract out the data from the now-unlinked node</span>\n<span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token namespace">ptr<span class="token punctuation">::</span></span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// free the node</span>\n<span class="token namespace">mem<span class="token punctuation">::</span></span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">from_raw</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">return</span> ret\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>问题是其他线程也可能同时运行 pop。 这些线程可以获得当前head的快照; 没有什么可以阻止它们读取<code>(*head).next</code>。 就在我们释放他们指向的节点之后，快照上的下一个——<strong>一个正在形成的<code>user-after-free</code>bug！</strong> 这就是症结所在。 我们希望使用无锁算法，但是许多算法遵循与上面的栈类似的模式，这使得我们没有明确的点可以安全地释放一个节点。 现在怎么办？</p><p>感觉这里描述的问题并不是很清楚,我加上一个<a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="noopener noreferrer">ABA问题</a></p><p>所有没有gc的系统在lock-free编程的是一定要考虑这个问题,具体来说就是假设T1,T2两个线程, 初始stack是a-&gt;b-&gt;c. 这是T1要pop,那么得到a,这时候a.next=b,此时发生了线程调度.然后切换到T2,T2 pop a, pop b,push a 所以stack里面是a-&gt;c. 然后切换到T1,这时候T1看到栈顶地址和自己取到的是一样的(a的地址),然后就把栈顶设置为a.next,也就是b,但是这时候b已经被释放了.</p><p>这是典型的ABAA问题: <img alt="aba问题" data-src="img/aba_problem.jpg" loading="lazy" class="lazy"></p><h2 id="基于epoch的内存回收"><a class="header-anchor" href="#基于epoch的内存回收" aria-hidden="true">#</a> 基于epoch的内存回收</h2><p>对于无锁代码，有几种不是基于 gc 的内存管理方法，但它们都归结为相同的核心特点:</p><ol><li>可达性有两个来源——数据结构和访问它的线程中的快照(引用)。 在删除一个节点之前，我们需要知道它不能以这两种方式中的任何一种方式到达。</li><li>一旦一个节点从数据结构中解除链接，就不会创建到达该节点的新快照(引用)。</li></ol><p>其中一个最优雅和有希望的回收方案是<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf" target="_blank" rel="noopener noreferrer">Keir Fraser’s epoch-based reclamation</a>，这来自于他的博士论文。</p><p>其基本思想是将未与数据结构链接的节点(可达性的第一个来源)隐藏起来，直到可以安全地删除它们。 在删除隐藏的节点之前，我们需要知道当时访问数据结构的所有线程都已经完成了它们正在执行的操作。 通过上面的特点2，这将意味着不再有任何引用留下(因为在此期间不可能创建新的引用)。 最困难的部分是在不同步的情况下完成所有这些工作。 否则，我们就失去了lock-free应该带来的好处！</p><p>epoch的工作原理是:</p><ol><li>A 全局epoch计数器(取值0、1和2) ;</li><li>A global list of garbage for each epoch;每个opoch都有一个全局垃圾列表;</li><li>每个线程的“活动”标志;</li><li>每个线程的epoch计数器</li></ol><p>epoch用于发现何时垃圾可以安全地释放，因为没有线程可以到达它。 与传统的 GC 不同，这不需要遍历实时数据; 这只是检查opoch计数器。</p><p>当一个线程想要对数据结构执行一个操作时，它首先设置它的<code>active</code>标志，然后更新它的本地epoch以匹配全局epoch。 如果线程从数据结构中删除一个节点，则将该节点添加到当前全局epoch的垃圾列表中。 (注意: 垃圾进入当前的全局epoch，而不是以前的本地快照，这一点非常重要。) 当它完成操作时，它清除<code>active</code>标志。</p><p>为了尝试收集垃圾(可以在任何时候执行) ，线程遍历所有参与线程的标志，并检查所有活动线程是否都在当前epoch中。 如果是这样，它可以尝试增加全局opoch(模3)。 如果增量成功，则可以释放两个eopch前的垃圾。</p><p>为什么我们需要三个epoch？ 因为“垃圾收集”是并发完成的，所以线程在任何时候都可能处于两个epoch之一(旧的epoch和新的epoch)。 但是，因为我们在递增之前检查所有活动线程都处于旧eopch中，所以可以保证没有活动线程处于第三个epoch中。</p><p>这个方案是经过精心设计的，以便在大多数时间里，线程只访问已经在缓存中或(通常)线程本地的数据。 只有在进行“ GC”时，才会涉及到改变全局epoch或者读取其他线程的eopch。 epoch 方法也与算法无关，易于使用，其性能与其他方法相比具有竞争力。</p><p>这个方案也证明非常适合Rust的所有权系统.</p><h2 id="the-rust-api"><a class="header-anchor" href="#the-rust-api" aria-hidden="true">#</a> The Rust API</h2><p>我们希望 Rust API 反映基于epoch的回收的基本原则:</p><ul><li>当对共享数据结构进行操作时，线程必须始终处于“活动”状态。</li><li>当线程处于活动状态时，从数据结构中读出的所有数据将保持分配状态，直到线程变为非活动状态。</li></ul><p>我们将利用 Rust 的所有权系统——特别是基于所有权的资源管理(又名 RAII)——在 epoch API 的类型签名中直接捕获这些约束。 这反过来将有助于确保我们正确管理epoch。</p><h3 id="guard"><a class="header-anchor" href="#guard" aria-hidden="true">#</a> Guard</h3><p>要对无锁数据结构进行操作，首先需要获得一个<code>guard</code>，这是一个所有值，表示线程处于活动状态:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Guard</span> <span class="token punctuation">{</span> <span class="token punctuation">...</span> <span class="token punctuation">}</span>\n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">pin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Guard</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Pin 函数将线程标记为 active，加载全局epoch，并可能尝试执行 GC (稍后将详细介绍)。 另一方面，Guard 的析构函数通过将线程标记为非活动状态退出epoch管理。</p><p>因为<code>Guard</code>表示“处于活动状态” ，所以借用<code>&amp;&#39;a Guard</code>保证线程在整个生存期内处于活动状态——这正是我们在无锁算法中绑定快照生存期所需要的。</p><p>为了使<code>Guard</code>能够工作，Crossbeam 提供了一组三指针类型，它们可以一起工作:</p><ul><li><code>Owned&lt;T&gt;</code>,类似于<code>Box&lt;T&gt;</code>,拥有所有权,并且这些数据还尚未放进并发数据结构中.</li><li><code>Shared&lt;&#39;a,T&gt;</code>,,类似于&amp;&#39;a T,指向并发数据结构中的数据,可能可访问,也可能不可访问,但是确保在生命周期&#39;a期间不会被释放.</li><li><code>Atomic&lt;T&gt;</code>,类似于<code>std::sync::atomic::AtomicPtr</code>,它使用 <code>Owned</code> 和 <code>Shared</code> 类型提供对指针的原子更新，并将它们连接到一个 <code>Guard</code>。</li></ul><p>然后我们一起来看看这些指针.</p><h3 id="owned-and-shared-pointers"><a class="header-anchor" href="#owned-and-shared-pointers" aria-hidden="true">#</a> Owned and Shared pointers</h3><h4 id="owned"><a class="header-anchor" href="#owned" aria-hidden="true">#</a> Owned</h4><p><code>Owned</code> 接口与Box几乎相同:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">...</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">type</span> <span class="token class-name">Target</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">;</span>\n    <span class="token punctuation">...</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">DerefMut</span> <span class="token keyword">for</span> <span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">...</span> <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="shared"><a class="header-anchor" href="#shared" aria-hidden="true">#</a> Shared</h4><p><code>Shared&lt;&#39;a,T&gt;</code>类似于<code>&amp;&#39;a T</code>,但是他可以<code>Deref</code>到<code>&amp;&#39;a T</code>. 它所提供的指针的生命周期实际上是 a。</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Shared</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token lifetime-annotation symbol">&#39;a</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">...</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Copy</span> <span class="token keyword">for</span> <span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">...</span> <span class="token punctuation">}</span>\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Clone</span> <span class="token keyword">for</span> <span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">...</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n   <span class="token keyword">type</span> <span class="token class-name">Target</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token class-name">T</span><span class="token punctuation">;</span>\n   <span class="token punctuation">...</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="atomic"><a class="header-anchor" href="#atomic" aria-hidden="true">#</a> Atomic</h3><p>crossbeam-epoch这个库的核心就是Atomic,它提供了对于nullable pointer的原子访问,将库的其他部分连接起来.</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">...</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">/// Create a new, null atomic pointer.</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">null</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们一起一次只看一个操作,因为这些操作的签名非常微妙.</p><h4 id="loading"><a class="header-anchor" href="#loading" aria-hidden="true">#</a> Loading</h4><p>首先从load开始</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">load</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> ord<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">,</span> _<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token class-name">Guard</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>为了完成这个任务，我们必须借用一个<code>Guard</code>。 如上所述，这是一种保证线程在整个生命周期中处于活动状态的方法。 作为回报，您将得到一个可选的 <code>Shared</code> 指针(如果 Atomic 当前为 null，则返回 None) ，其生命期绑定到<code>Guard</code>。</p><p>将其与标准库的 AtomicPtr 接口进行比较很有意思，在这个接口中 load 返回一个 * mut t。 AtomicPtr的load签名</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> order<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token class-name">T</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="store"><a class="header-anchor" href="#store" aria-hidden="true">#</a> store</h4><p>Storing is a bit more complicated because of the multiple pointer types in play.</p><p>如果我们只是想写一个 Owned 指针或一个 null 值，我们甚至不需要线程是活动的。 我们只是将所有权转移到数据结构中，不需要任何关于指针生命周期的保证:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> ord<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但有时，我们希望将所有权转移到数据结构中，并立即获得一个指向所转移数据的<code>Shared</code>指针——例如，因为我们希望添加到数据结构中同一节点的附加链接。 在这种情况下，我们需要将其生命周期和一个<code>Guard</code>联系起来:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">store_and_ref</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span>\n                             val<span class="token punctuation">:</span> <span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n                             ord<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">,</span>\n                             _<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token class-name">Guard</span><span class="token punctuation">)</span>\n                             <span class="token punctuation">-&gt;</span> <span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>请注意，val的运行时表示和返回值完全相同——我们传入一个指针，然后得到相同的指针。 但是从Rust的观点来看，这一步的所有权状况发生了根本性的变化。</p><p>最后,我们可以讲一个<code>Shared</code>指针存回数据结构中.</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">store_shared</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> ord<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个操作不需要guard,因为我们没有学到任何关于指针生命周期的新信息.</p><h4 id="cas"><a class="header-anchor" href="#cas" aria-hidden="true">#</a> CAS</h4><p>compare-and-set,换出一个<code>Shared</code>,放入一个<code>Owned</code>:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span>\n               old<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n               new<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n               ord<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">)</span>\n               <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>与store一样，此操作不需要<code>Guard</code>; 它不产生新的生命周期信息。 结果返回CAS是否成功; 如果不成功，新指针的所有权将返回给调用者。</p><p>我们有一个类似的操作<code>store_and_ref</code>:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">cas_and_ref</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span>\n                           old<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n                           new<span class="token punctuation">:</span> <span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n                           ord<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">,</span>\n                           _<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token class-name">Guard</span><span class="token punctuation">)</span>\n                           <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Owned</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>区别在于如果成功,会返回一个<code>Shared</code>指针,指向刚刚放入的数据.</p><p>最后,我们可以使用一个Shared替换另一个Shared.</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">cas_shared</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span>\n                             old<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n                             new<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n                             ord<span class="token punctuation">:</span> <span class="token class-name">Ordering</span><span class="token punctuation">)</span>\n                             <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>当 CAS 成功时，布尔返回值为 true。</p><h4 id="释放内存"><a class="header-anchor" href="#释放内存" aria-hidden="true">#</a> 释放内存</h4><p>上述所有机制的目标就是: 释放不再可及(no longer reachable)的内存. 当一个节点已经从数据结构中unlink,unlink的线程可以通知他的<code>Guard</code>内存应被回收:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span> <span class="token class-name">Guard</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">unlinked</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token class-name">Shared</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此操作将 Shared 指针添加到适当的垃圾列表中，允许在两个epoch之后释放它。 该行动是unsafe，因为它声称:</p><ul><li>从数据结构无法访问指针,</li><li>没有其他线程会再针对这个val,调用unlink</li></ul><p>但关键的是，其他线程可能会继续引用这个共享指针; epoch 系统将确保在实际释放指针时没有线程再继续引用这个共享指针。</p><p>这里的共享指针的生命周期和<code>Guard</code>之间没有特定的联系; 如果我们有一个可达的<code>Shared</code>指针，我们知道它来自的<code>Guard</code>是活动的。</p><h4 id="基于epoch的特雷贝尔栈"><a class="header-anchor" href="#基于epoch的特雷贝尔栈" aria-hidden="true">#</a> 基于epoch的特雷贝尔栈</h4><p>下面给出使用Crossbeam实现的特雷贝尔栈的完整源码:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>sync<span class="token punctuation">::</span>atomic<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Acquire</span><span class="token punctuation">,</span> <span class="token class-name">Release</span><span class="token punctuation">,</span> <span class="token class-name">Relaxed</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>ptr<span class="token punctuation">;</span>\n\n<span class="token keyword">use</span> <span class="token namespace">crossbeam<span class="token punctuation">::</span>mem<span class="token punctuation">::</span>epoch<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token class-name">Atomic</span><span class="token punctuation">,</span> <span class="token class-name">Owned</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">TreiberStack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    head<span class="token punctuation">:</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">struct</span> <span class="token type-definition class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    data<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>\n    next<span class="token punctuation">:</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">TreiberStack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">TreiberStack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n        <span class="token class-name">TreiberStack</span> <span class="token punctuation">{</span>\n            head<span class="token punctuation">:</span> <span class="token class-name">Atomic</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// allocate the node via Owned</span>\n        <span class="token keyword">let</span> <span class="token keyword">mut</span> n <span class="token operator">=</span> <span class="token class-name">Owned</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Node</span> <span class="token punctuation">{</span>\n            data<span class="token punctuation">:</span> t<span class="token punctuation">,</span>\n            next<span class="token punctuation">:</span> <span class="token class-name">Atomic</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// become active</span>\n        <span class="token keyword">let</span> guard <span class="token operator">=</span> <span class="token namespace">epoch<span class="token punctuation">::</span></span><span class="token function">pin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">loop</span> <span class="token punctuation">{</span>\n            <span class="token comment">// snapshot current head</span>\n            <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Relaxed</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>guard<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// update `next` pointer with snapshot</span>\n            n<span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">store_shared</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token class-name">Relaxed</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// if snapshot is still good, link in the new node</span>\n            <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">cas_and_ref</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token class-name">Release</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>guard<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">Ok</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span><span class="token punctuation">,</span>\n                <span class="token class-name">Err</span><span class="token punctuation">(</span>owned<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">=</span> owned<span class="token punctuation">,</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n        <span class="token comment">// become active</span>\n        <span class="token keyword">let</span> guard <span class="token operator">=</span> <span class="token namespace">epoch<span class="token punctuation">::</span></span><span class="token function">pin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">loop</span> <span class="token punctuation">{</span>\n            <span class="token comment">// take a snapshot</span>\n            <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Acquire</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>guard<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// the stack is non-empty</span>\n                <span class="token class-name">Some</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// read through the snapshot, *safely*!</span>\n                    <span class="token keyword">let</span> next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Relaxed</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>guard<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                    <span class="token comment">// if snapshot is still good, update from `head` to `next`</span>\n                    <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">cas_shared</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token class-name">Release</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>\n                            <span class="token comment">// mark the node as unlinked</span>\n                            guard<span class="token punctuation">.</span><span class="token function">unlinked</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                            <span class="token comment">// extract out the data from the now-unlinked node</span>\n                            <span class="token keyword">return</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token namespace">ptr<span class="token punctuation">::</span></span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">}</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n\n                <span class="token comment">// we observed the stack empty</span>\n                <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">None</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br></div></div><p>一些现象:</p><ul><li><p>该算法的基本逻辑与依赖于 GC 的版本相同，只是我们显式地将弹出的节点标记为“ unlinked”。 一般来说，可以采用“现成的”无锁算法(一般的算法实现通常假设GC的存在) ，并以这种方式直接针对 Crossbeam 对其进行编码。</p></li><li><p>捕获快照后，我们可以在不使用不安全的情况下解除对快照的引用，因为<code>Guard</code>保证了快照一定没被释放。</p></li><li><p>在这里使用 <code>ptr::read</code> 是合理的，因为我们使用了比较并交换来确保只有一个线程调用它，而且 epoch 回收方案不运行析构函数，而只是释放内存。</p></li></ul><p>关于释放的最后一点需要更多的注释，因此让我们通过讨论垃圾来总结 API 描述。</p><h4 id="管理垃圾"><a class="header-anchor" href="#管理垃圾" aria-hidden="true">#</a> 管理垃圾</h4><p>Crossbeam 中的设计将epoch管理视为所有数据结构共享的服务: 存在一个全局的唯一的的epoch 状态，对于每个线程状态有一个本地状态。 这使得 epoch API 的使用非常简单，因为没有每个数据结构的设置。 这还意味着(相当简单的)空间使用量与使用 epoch 的线程数量相关，而不是与数据结构的数量相关。</p><p>Crossbeam 的实现与现有的 epoch 文献的一个不同之处在于，每个线程都保存本地垃圾列表。 也就是说，当一个线程将一个节点标记为“ unlinked”时，该节点被添加到一些线程本地数据中，而不是立即添加到全局垃圾列表中(这将需要额外的同步)。</p><p>每次调用 <code>epoch::pin()</code>时，当前线程将检查其本地垃圾是否超过了收集阈值，如果超过，则将尝试进行收集。 同样，每当调用 <code>epoch::pin()</code>时，如果全局 epoch 已超过前一个快照，则当前线程可以收集它的一些垃圾。 除了避免在垃圾列表周围进行全局同步之外，这个新方案还将实际释放内存的工作分散到访问数据结构的所有线程中。</p><p>因为只有当所有活动线程都在当前epoch上时，GC 才会发生，所以不可能总是收集。 但实际上，给定线程上的垃圾很少超过阈值。</p><p>但是有一个问题: 因为 GC 可能会失败，如果一个线程正在退出，那么它需要处理它的垃圾。 因此 Crossbeam 实现还具有全局垃圾列表，当线程退出时，这些垃圾列表用作最后的抛垃圾的地方。 这些全局垃圾列表由成功递增全局epoch的线程收集。</p><p>最后，“收集”垃圾意味着什么？ 如上所述，库仅释放内存; 它不运行析构函数。</p><p>从概念上讲，框架将对象的破坏分为两部分: 销毁 / 移出内部数据，以及释放包含该数据的对象。 前者应该与调用 unlinked 同时发生——也就是说，除了实际释放对象的能力之外，还有一个唯一的线程在每个意义上拥有对象。 后者发生在某个未知的后续点，当已知的对象不再被引用时。 这确实对用户施加了一种义务: 通过快照访问应该只读取在释放之前有效的数据。 但是，无锁数据结构基本上都是这样，它倾向于在与容器相关的数据(即原子字段)和包含的实际数据(如 Node 中的数据字段)之间有一个明确的分隔。</p><p>以这种方式将对象拆分意味着在可预测的时间内以同步方式运行析构函数，减轻了 GC 的痛苦之一，并允许将框架用于非<code>&#39;static</code>(和非<code>Send</code>)数据。</p><h2 id="展望"><a class="header-anchor" href="#展望" aria-hidden="true">#</a> 展望</h2><p>横梁仍处于起步阶段。 这里的工作为探索 Rust 中大范围的无锁数据结构奠定了基础，我希望 Crossbeam 最终发挥类似于 java.util.concurrent for Rust 的作用——包括无锁 hashmap、窃取工作的 deques 和轻量级任务引擎。 如果你对这项工作感兴趣，我很乐意帮忙！</p><h2 id="我的一些心得"><a class="header-anchor" href="#我的一些心得" aria-hidden="true">#</a> 我的一些心得</h2><p>我在尝试编写lock-free stack的初期,并没有接触crossbeam,只是在碰到ABA问题,无法解决以后才寻求crossbeam的支持. 所以我实现的无锁栈和文中的有一些区别,但是一致的.下面附上我的实现.</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>sync<span class="token punctuation">::</span>atomic<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span>\n<span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">crossbeam_epoch</span> <span class="token keyword">as</span> epoch<span class="token punctuation">;</span>\n<span class="token keyword">use</span> <span class="token namespace">epoch<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Atomic</span><span class="token punctuation">,</span> <span class="token class-name">Owned</span><span class="token punctuation">,</span> <span class="token class-name">Shared</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Node</span> <span class="token punctuation">{</span>\n    value<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span>\n    next<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token class-name">Node</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">LockFreeStack</span> <span class="token punctuation">{</span>\n    next<span class="token punctuation">:</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">Node</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">unsafe</span> <span class="token keyword">impl</span> <span class="token class-name">Sync</span> <span class="token keyword">for</span> <span class="token class-name">LockFreeStack</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">unsafe</span> <span class="token keyword">impl</span> <span class="token class-name">Send</span> <span class="token keyword">for</span> <span class="token class-name">LockFreeStack</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">impl</span> <span class="token class-name">LockFreeStack</span> <span class="token punctuation">{</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">LockFreeStack</span> <span class="token punctuation">{</span>\n        <span class="token class-name">LockFreeStack</span> <span class="token punctuation">{</span>\n            next<span class="token punctuation">:</span> <span class="token class-name">Atomic</span><span class="token punctuation">::</span><span class="token function">null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> v<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n        <span class="token keyword">let</span> guard <span class="token operator">=</span> <span class="token namespace">epoch<span class="token punctuation">::</span></span><span class="token function">pin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">let</span>   <span class="token keyword">mut</span> new <span class="token operator">=</span> <span class="token class-name">Owned</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Node</span> <span class="token punctuation">{</span>\n            value<span class="token punctuation">:</span> v<span class="token punctuation">,</span>\n            next<span class="token punctuation">:</span> <span class="token namespace">std<span class="token punctuation">::</span>ptr<span class="token punctuation">::</span></span><span class="token function">null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">loop</span> <span class="token punctuation">{</span>\n            <span class="token keyword">let</span>   old <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Relaxed</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>guard<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            new<span class="token punctuation">.</span>next<span class="token operator">=</span>old<span class="token punctuation">.</span><span class="token function">as_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">match</span>  <span class="token keyword">self</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">compare_and_set</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> new<span class="token punctuation">,</span> <span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Release</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>guard<span class="token punctuation">)</span><span class="token punctuation">{</span>\n                <span class="token class-name">Ok</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">break</span><span class="token punctuation">,</span>\n                <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>\n                    new<span class="token operator">=</span>e<span class="token punctuation">.</span>new<span class="token punctuation">;</span>\n                    <span class="token comment">// spin_loop_hint();</span>\n                <span class="token punctuation">}</span><span class="token punctuation">,</span>\n            <span class="token punctuation">}</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> guard <span class="token operator">=</span> <span class="token namespace">epoch<span class="token punctuation">::</span></span><span class="token function">pin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">loop</span> <span class="token punctuation">{</span>\n            <span class="token keyword">let</span>   old <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token namespace">std<span class="token punctuation">::</span>sync<span class="token punctuation">::</span>atomic<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Acquire</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>guard<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">/*\n            按照as_ref的文档说明,old的load不能是Relaxed,只要确保old的写的另一方是Release,就是安全的\n            我们这里无论是Push还是Pop对于old的set访问用得都是Release,因此是安全的.\n            */</span>\n            <span class="token keyword">match</span> <span class="token keyword">unsafe</span><span class="token punctuation">{</span>old<span class="token punctuation">.</span><span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">{</span>\n                <span class="token class-name">None</span><span class="token operator">=&gt;</span><span class="token keyword">return</span> <span class="token class-name">None</span><span class="token punctuation">,</span>\n                <span class="token class-name">Some</span><span class="token punctuation">(</span>old2<span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>\n                    <span class="token keyword">let</span> next<span class="token operator">=</span>old2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n\n                    <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">compare_and_set</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> <span class="token class-name">Shared</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Release</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>guard<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is_ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n                        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>\n                            <span class="token comment">/*\n                            按照defer_destroy文档,只要我们保证old不会再其他线程使用就是安全的\n                            而我们非常确信,这个old不会被其他线程使用,\n                            因为这里是defer_destroy,所以解决了ABA问题 (https://en.wikipedia.org/wiki/ABA_problem)\n                            */</span>\n                            guard<span class="token punctuation">.</span><span class="token function">defer_destroy</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token punctuation">}</span>\n                        <span class="token keyword">return</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>old2<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                    <span class="token function">spin_loop_hint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">LockFreeStack</span> <span class="token punctuation">{</span>\n    <span class="token comment">/*\n     因为&amp;mut self保证了不会有其他人同时操作这个Stack,因此可以放心的一个一个移除即可.\n    */</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> guard <span class="token operator">=</span> <span class="token namespace">epoch<span class="token punctuation">::</span></span><span class="token function">pin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">let</span> <span class="token keyword">mut</span> next <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Relaxed</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>guard<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token class-name">Node</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token operator">!</span>next<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">/*\n            这里的next确定是通过Owned分配的,所以没有安全问题\n            并且drop持有的是mutable stack,只有一个线程可以访问,所以也没有并发问题.\n            */</span>\n            <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token class-name">Owned</span><span class="token punctuation">::</span><span class="token function">from_raw</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n            <span class="token comment">// println!(&quot;drop {}&quot;, n.value);</span>\n            next <span class="token operator">=</span> n<span class="token punctuation">.</span>next <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span>  <span class="token class-name">Node</span> <span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br></div></div><p>这里使用了i32,而没有使用T,只是为了简化问题,能够聚焦lock-free编程.</p><p>完整的代码位于我的<a href="https://github.com/nkbai/lock-free-stack/blob/epoch_i32/src/lib.rs" target="_blank" rel="noopener noreferrer">github</a></p>',134)];e.render=function(a,p,e,o,c,l){return n(),s("div",null,t)};export{p as __pageData,e as default};
