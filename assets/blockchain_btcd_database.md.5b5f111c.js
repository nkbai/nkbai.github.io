import{_ as s,c as n,o as a,N as l}from"./chunks/framework.3a9190c5.js";const A=JSON.parse('{"title":"database","description":"","frontmatter":{"title":"database","date":"2018-11-30T03:54:04.000Z","draft":false,"markup":"mmark"},"headers":[],"relativePath":"blockchain/btcd/database.md"}'),e={name:"blockchain/btcd/database.md"},p=l(`<h1 id="btcd数据库设计" tabindex="-1">btcd数据库设计 <a class="header-anchor" href="#btcd数据库设计" aria-label="Permalink to &quot;btcd数据库设计&quot;">​</a></h1><h2 id="块的存储" tabindex="-1">块的存储 <a class="header-anchor" href="#块的存储" aria-label="Permalink to &quot;块的存储&quot;">​</a></h2><p>由于区块链块信息的不变性,btcd将整个比特币的区块想象成一个超级大的平坦文件,块与块相邻存放. 由于文件系统的限制,将这个超级大文件拆分成n多文件块,每块都是512M. 假定我知道我要读的第3000block的起始是1000000000000,大小是3M,那么很简单的算法. 一个文件块是512M字节=512<em>1024</em>1024=536870912字节, 因此,我位于第1862(1000000000000/536870912)文件块,文件块内偏移是346361856(1000000000000%536870912)字节, 那么我就读取第1862文件块中的346361856到349507584即可.</p><p>当然具体实现还要考虑到缓存以及block跨越文件块的问题</p><h2 id="接口" tabindex="-1">接口 <a class="header-anchor" href="#接口" aria-label="Permalink to &quot;接口&quot;">​</a></h2><p>btcd关于数据的设计完全是面向接口的,最终暴露出来的是ffldb/interface.go中的几个接口, 主要是DB,Cursor,Bucket,Tx 全部都是接口. 真正的实现位于ffldb/db.go中</p><ul><li>Bucket是真正存数据的地方,并且提供了直接读写KV接口</li><li>一组读写Bucket使用Tx进行管理,</li><li>Cursor是用来遍历Bucket</li></ul><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// db represents a collection of namespaces which are persisted and implements</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// the database.DB interface.  All database access is performed through</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// transactions which are obtained through the specific Namespace.</span></span>
<span class="line"><span style="color:#89DDFF;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">db</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	writeLock sync</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Mutex   </span><span style="color:#676E95;font-style:italic;">// Limit to one write transaction at a time.</span></span>
<span class="line"><span style="color:#A6ACCD;">	closeLock sync</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">RWMutex </span><span style="color:#676E95;font-style:italic;">// Make database close block while txns active.</span></span>
<span class="line"><span style="color:#A6ACCD;">	closed    </span><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;">         </span><span style="color:#676E95;font-style:italic;">// Is the database closed?</span></span>
<span class="line"><span style="color:#A6ACCD;">	store     </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">blockStore  </span><span style="color:#676E95;font-style:italic;">// Handles read/writing blocks to flat files.</span></span>
<span class="line"><span style="color:#A6ACCD;">	cache     </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">dbCache     </span><span style="color:#676E95;font-style:italic;">// Cache layer which wraps underlying leveldb DB.</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// transaction represents a database transaction.  It can either be read-only or</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// read-write and implements the database.Bucket interface.  The transaction</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// provides a root bucket against which all read and writes occur.</span></span>
<span class="line"><span style="color:#89DDFF;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">transaction</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	managed        </span><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;">             </span><span style="color:#676E95;font-style:italic;">// Is the transaction managed?</span></span>
<span class="line"><span style="color:#A6ACCD;">	closed         </span><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;">             </span><span style="color:#676E95;font-style:italic;">// Is the transaction closed?</span></span>
<span class="line"><span style="color:#A6ACCD;">	writable       </span><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;">             </span><span style="color:#676E95;font-style:italic;">// Is the transaction writable?</span></span>
<span class="line"><span style="color:#A6ACCD;">	db             </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">db              </span><span style="color:#676E95;font-style:italic;">// DB instance the tx was created from.</span></span>
<span class="line"><span style="color:#A6ACCD;">	snapshot       </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">dbCacheSnapshot </span><span style="color:#676E95;font-style:italic;">// Underlying snapshot for txns.</span></span>
<span class="line"><span style="color:#A6ACCD;">	metaBucket     </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">bucket          </span><span style="color:#676E95;font-style:italic;">// The root metadata bucket.</span></span>
<span class="line"><span style="color:#A6ACCD;">	blockIdxBucket </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">bucket          </span><span style="color:#676E95;font-style:italic;">// The block index bucket.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#676E95;font-style:italic;">// Blocks that need to be stored on commit.  The pendingBlocks map is</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#676E95;font-style:italic;">// kept to allow quick lookups of pending data by block hash.</span></span>
<span class="line"><span style="color:#A6ACCD;">	pendingBlocks    </span><span style="color:#89DDFF;">map[</span><span style="color:#A6ACCD;">chainhash</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Hash</span><span style="color:#89DDFF;">]</span><span style="color:#C792EA;">int</span></span>
<span class="line"><span style="color:#A6ACCD;">	pendingBlockData </span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;">pendingBlock</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#676E95;font-style:italic;">// Keys that need to be stored or deleted on commit.</span></span>
<span class="line"><span style="color:#A6ACCD;">	pendingKeys   </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">treap</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Mutable</span></span>
<span class="line"><span style="color:#A6ACCD;">	pendingRemove </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">treap</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Mutable</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#676E95;font-style:italic;">// Active iterators that need to be notified when the pending keys have</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#676E95;font-style:italic;">// been updated so the cursors can properly handle updates to the</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#676E95;font-style:italic;">// transaction state.</span></span>
<span class="line"><span style="color:#A6ACCD;">	activeIterLock sync</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">RWMutex</span></span>
<span class="line"><span style="color:#A6ACCD;">	activeIters    </span><span style="color:#89DDFF;">[]*</span><span style="color:#A6ACCD;">treap</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Iterator</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// bucket is an internal type used to represent a collection of key/value pairs</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// and implements the database.Bucket interface.</span></span>
<span class="line"><span style="color:#89DDFF;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">bucket</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	tx </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">transaction</span></span>
<span class="line"><span style="color:#A6ACCD;">	id </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">]</span><span style="color:#C792EA;">byte</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cursor is an internal type used to represent a cursor over key/value pairs</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// and nested buckets of a bucket and implements the database.Cursor interface.</span></span>
<span class="line"><span style="color:#89DDFF;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">cursor</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	bucket      </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">bucket</span></span>
<span class="line"><span style="color:#A6ACCD;">	dbIter      iterator</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Iterator</span></span>
<span class="line"><span style="color:#A6ACCD;">	pendingIter iterator</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Iterator</span></span>
<span class="line"><span style="color:#A6ACCD;">	currentIter iterator</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Iterator</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>这里面实现机制比较复杂,基本思路是用leveldb来存block的元数据信息,真正的block是按照文件进行存储的. 这样的设计好处是规避了leveldb写大量数据时的低性能问题.</p><p>同时还有缓存管理,尤其是transaction中使用的treap模块 很有意思,需要专门花时间研究, treap这个数据结构可以做到检索,插入,删除都是O(logn), 是一个比较巧妙的设计.</p>`,10),t=[p];function o(c,r,i,y,b,C){return a(),n("div",null,t)}const d=s(e,[["render",o]]);export{A as __pageData,d as default};
