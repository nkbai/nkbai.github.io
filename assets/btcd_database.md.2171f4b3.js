import{o as n,c as s,e as a}from"./app.f7f738b8.js";const e='{"title":"database","description":"","frontmatter":{"title":"database","date":"2018-11-30T03:54:04.000Z","draft":false,"markup":"mmark"},"headers":[{"level":2,"title":"块的存储","slug":"块的存储"},{"level":2,"title":"接口","slug":"接口"}],"relativePath":"btcd/database.md","lastUpdated":1561507892000}',t={},p=[a('<h1 id="btcd数据库设计"><a class="header-anchor" href="#btcd数据库设计" aria-hidden="true">#</a> btcd数据库设计</h1><h2 id="块的存储"><a class="header-anchor" href="#块的存储" aria-hidden="true">#</a> 块的存储</h2><p>由于区块链块信息的不变性,btcd将整个比特币的区块想象成一个超级大的平坦文件,块与块相邻存放. 由于文件系统的限制,将这个超级大文件拆分成n多文件块,每块都是512M. 假定我知道我要读的第3000block的起始是1000000000000,大小是3M,那么很简单的算法. 一个文件块是512M字节=512<em>1024</em>1024=536870912字节, 因此,我位于第1862(1000000000000/536870912)文件块,文件块内偏移是346361856(1000000000000%536870912)字节, 那么我就读取第1862文件块中的346361856到349507584即可.</p><p>当然具体实现还要考虑到缓存以及block跨越文件块的问题</p><h2 id="接口"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h2><p>btcd关于数据的设计完全是面向接口的,最终暴露出来的是ffldb/interface.go中的几个接口, 主要是DB,Cursor,Bucket,Tx 全部都是接口. 真正的实现位于ffldb/db.go中</p><ul><li>Bucket是真正存数据的地方,并且提供了直接读写KV接口</li><li>一组读写Bucket使用Tx进行管理,</li><li>Cursor是用来遍历Bucket</li></ul><div class="language-go line-numbers-mode"><pre><code><span class="token comment">// db represents a collection of namespaces which are persisted and implements</span>\n<span class="token comment">// the database.DB interface.  All database access is performed through</span>\n<span class="token comment">// transactions which are obtained through the specific Namespace.</span>\n<span class="token keyword">type</span> db <span class="token keyword">struct</span> <span class="token punctuation">{</span>\n\twriteLock sync<span class="token punctuation">.</span>Mutex   <span class="token comment">// Limit to one write transaction at a time.</span>\n\tcloseLock sync<span class="token punctuation">.</span>RWMutex <span class="token comment">// Make database close block while txns active.</span>\n\tclosed    <span class="token builtin">bool</span>         <span class="token comment">// Is the database closed?</span>\n\tstore     <span class="token operator">*</span>blockStore  <span class="token comment">// Handles read/writing blocks to flat files.</span>\n\tcache     <span class="token operator">*</span>dbCache     <span class="token comment">// Cache layer which wraps underlying leveldb DB.</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// transaction represents a database transaction.  It can either be read-only or</span>\n<span class="token comment">// read-write and implements the database.Bucket interface.  The transaction</span>\n<span class="token comment">// provides a root bucket against which all read and writes occur.</span>\n<span class="token keyword">type</span> transaction <span class="token keyword">struct</span> <span class="token punctuation">{</span>\n\tmanaged        <span class="token builtin">bool</span>             <span class="token comment">// Is the transaction managed?</span>\n\tclosed         <span class="token builtin">bool</span>             <span class="token comment">// Is the transaction closed?</span>\n\twritable       <span class="token builtin">bool</span>             <span class="token comment">// Is the transaction writable?</span>\n\tdb             <span class="token operator">*</span>db              <span class="token comment">// DB instance the tx was created from.</span>\n\tsnapshot       <span class="token operator">*</span>dbCacheSnapshot <span class="token comment">// Underlying snapshot for txns.</span>\n\tmetaBucket     <span class="token operator">*</span>bucket          <span class="token comment">// The root metadata bucket.</span>\n\tblockIdxBucket <span class="token operator">*</span>bucket          <span class="token comment">// The block index bucket.</span>\n\n\t<span class="token comment">// Blocks that need to be stored on commit.  The pendingBlocks map is</span>\n\t<span class="token comment">// kept to allow quick lookups of pending data by block hash.</span>\n\tpendingBlocks    <span class="token keyword">map</span><span class="token punctuation">[</span>chainhash<span class="token punctuation">.</span>Hash<span class="token punctuation">]</span><span class="token builtin">int</span>\n\tpendingBlockData <span class="token punctuation">[</span><span class="token punctuation">]</span>pendingBlock\n\n\t<span class="token comment">// Keys that need to be stored or deleted on commit.</span>\n\tpendingKeys   <span class="token operator">*</span>treap<span class="token punctuation">.</span>Mutable\n\tpendingRemove <span class="token operator">*</span>treap<span class="token punctuation">.</span>Mutable\n\n\t<span class="token comment">// Active iterators that need to be notified when the pending keys have</span>\n\t<span class="token comment">// been updated so the cursors can properly handle updates to the</span>\n\t<span class="token comment">// transaction state.</span>\n\tactiveIterLock sync<span class="token punctuation">.</span>RWMutex\n\tactiveIters    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>treap<span class="token punctuation">.</span>Iterator\n<span class="token punctuation">}</span>\n<span class="token comment">// bucket is an internal type used to represent a collection of key/value pairs</span>\n<span class="token comment">// and implements the database.Bucket interface.</span>\n<span class="token keyword">type</span> bucket <span class="token keyword">struct</span> <span class="token punctuation">{</span>\n\ttx <span class="token operator">*</span>transaction\n\tid <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">byte</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// cursor is an internal type used to represent a cursor over key/value pairs</span>\n<span class="token comment">// and nested buckets of a bucket and implements the database.Cursor interface.</span>\n<span class="token keyword">type</span> cursor <span class="token keyword">struct</span> <span class="token punctuation">{</span>\n\tbucket      <span class="token operator">*</span>bucket\n\tdbIter      iterator<span class="token punctuation">.</span>Iterator\n\tpendingIter iterator<span class="token punctuation">.</span>Iterator\n\tcurrentIter iterator<span class="token punctuation">.</span>Iterator\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>这里面实现机制比较复杂,基本思路是用leveldb来存block的元数据信息,真正的block是按照文件进行存储的. 这样的设计好处是规避了leveldb写大量数据时的低性能问题.</p><p>同时还有缓存管理,尤其是transaction中使用的treap模块 很有意思,需要专门花时间研究, treap这个数据结构可以做到检索,插入,删除都是O(logn), 是一个比较巧妙的设计.</p>',10)];t.render=function(a,e,t,c,o,l){return n(),s("div",null,p)};export{e as __pageData,t as default};
