import{_ as l,c as p,o as e,N as n,x as s,a}from"./chunks/framework.3a9190c5.js";const R=JSON.parse('{"title":"9.libra中的vrf","description":"","frontmatter":{"title":"9.libra中的vrf","date":"2019-07-05T01:55:01.000Z","draft":false,"tags":["rust","blockchain","libra"],"series":["libra"],"categories":["技术相关"]},"headers":[],"relativePath":"blockchain/libra/9.libria_vrf.md"}'),o={name:"blockchain/libra/9.libria_vrf.md"},t=n('<p>Libra中采用的椭圆曲线是ED25519,而不是像以太坊比特币使用的是secp256k1. 虽然有不同,但是从本质上来说他们都是椭圆曲线,基本性质都是完全相同的.因此适用于S256曲线的VRF算法在Libra中也是相通的.</p><h2 id="_1-ed25519" tabindex="-1">1. ED25519 <a class="header-anchor" href="#_1-ed25519" aria-label="Permalink to &quot;1. ED25519&quot;">​</a></h2><p><a href="http://ed25519.cr.yp.to/Ed25519%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%EF%BC%8C%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E8%AF%81%E7%9A%84%E6%80%A7%E8%83%BD%E9%83%BD%E6%9E%81%E9%AB%98%EF%BC%8C" target="_blank" rel="noreferrer">http://ed25519.cr.yp.to/Ed25519是一个数字签名算法，签名和验证的性能都极高，</a> 一个4核2.4GHz 的 Westmere cpu，每秒可以验证 71000 个签名，安全性极高，等价于RSA约3000-bit。签名过程不依赖随机数生成器，不依赖hash函数的防碰撞性，没有时间通道攻击的问题，并且签名很小，只有64字节，公钥也很小，只有32字节。 部署情 况：<a href="http://ianix.com/pub/ed25519-deployment.html" target="_blank" rel="noreferrer">http://ianix.com/pub/ed25519-deployment.html</a></p><p>同时在zcash中签名使用了ED25519,也就是在隐私交易方面,ED25519也有其独特应用之处,这应该也是主打隐私牌的Libra采用它的原因.</p><h2 id="_2-什么是vrf" tabindex="-1">2. 什么是VRF <a class="header-anchor" href="#_2-什么是vrf" aria-label="Permalink to &quot;2. 什么是VRF&quot;">​</a></h2><p>内容主要来自我的另一篇文章<a href="http://stevenbai.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82vrf/" target="_blank" rel="noreferrer">一篇文章搞懂VRF</a></p><p>VRF全称是verifiable random function ,也就是可验证随机数. 他有两个特性, 他产生的是随机数,第二还是可验证的.</p>',7),r=s("p",null,[a("我直接引用"),s("a",{href:"https://en.wikipedia.org/wiki/Verifiable_random_function",target:"_blank",rel:"noreferrer"},"维基百科上的VRF"),a(",就是说针对一个输入x,一个私钥SK的拥有者可以计算"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",null,"y"),s("mo",null,"="),s("mi",null,"F"),s("mi",null,"S"),s("mi",null,"K"),s("mo",null,"("),s("mi",null,"x"),s("mo",null,")")]),s("annotation",{encoding:"application/x-tex"},"y=FSK(x)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.75em"}}),s("span",{class:"strut bottom",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mrel"},"="),s("span",{class:"mord mathit",style:{"margin-right":"0.13889em"}},"F"),s("span",{class:"mord mathit",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mord mathit",style:{"margin-right":"0.07153em"}},"K"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"x"),s("span",{class:"mclose"},")")])])]),a("和证明"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",null,"P"),s("mi",null,"S"),s("mi",null,"K"),s("mo",null,"("),s("mi",null,"x"),s("mo",null,")")]),s("annotation",{encoding:"application/x-tex"},"PSK(x)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.75em"}}),s("span",{class:"strut bottom",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.13889em"}},"P"),s("span",{class:"mord mathit",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mord mathit",style:{"margin-right":"0.07153em"}},"K"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"x"),s("span",{class:"mclose"},")")])])]),a(". 依据证明(proof)和SK对应的公钥PK("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",null,"P"),s("mi",null,"K"),s("mo",null,"="),s("msup",null,[s("mi",null,"g"),s("mrow",null,[s("mi",null,"S"),s("mi",null,"K")])])]),s("annotation",{encoding:"application/x-tex"},"PK=g^{SK}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.8413309999999999em"}}),s("span",{class:"strut bottom",style:{height:"1.035771em","vertical-align":"-0.19444em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.13889em"}},"P"),s("span",{class:"mord mathit",style:{"margin-right":"0.07153em"}},"K"),s("span",{class:"mrel"},"="),s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.03588em"}},"g"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mord mathit",style:{"margin-right":"0.07153em"}},"K")])])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])]),a("),任何人都可以验证y是被正确计算的,但是不能知道SK是什么.")],-1),c=n('<p>原文中提到了使用双线性映射来做这个事情,当然VRF可以有很多种不同的实现,只要满足上面提出的条件即可.一个是随机数,另一个是可验证.</p><p>简单解释一下:</p><ol><li>验证人只知道x,在SK持有人没有广播之前不知道随机数是什么</li><li>SK持有人无法伪造随机数,一旦x确定,随机数也确定了. 这就是所谓的随机数(除了SK持有人之外,其他任何人事先不知道) 可验证(知道PK的任何人都知道SK生成的随机数是否合规)</li></ol><h2 id="_3-libra中vrf的实现" tabindex="-1">3. Libra中VRF的实现 <a class="header-anchor" href="#_3-libra中vrf的实现" aria-label="Permalink to &quot;3. Libra中VRF的实现&quot;">​</a></h2><p>Libra中对于VRF的实现依据来自于<a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04" target="_blank" rel="noreferrer"> Verifiable Random Functions (VRFs) draft-irtf-cfrg-vrf-04</a> 感兴趣的可以读读这篇标准草案</p><h3 id="_3-1-推导中用到的符号的含义" tabindex="-1">3.1 推导中用到的符号的含义 <a class="header-anchor" href="#_3-1-推导中用到的符号的含义" aria-label="Permalink to &quot;3.1 推导中用到的符号的含义&quot;">​</a></h3>',6),i=s("p",null,[a("B:ED25519曲线中的基点 SK:私钥 x:可以认为是私钥,或者有私钥推导出来. Y:公钥,其中"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",null,"Y"),s("mo",null,"="),s("msup",null,[s("mi",null,"B"),s("mi",null,"x")])]),s("annotation",{encoding:"application/x-tex"},"Y=B^x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.68333em"}}),s("span",{class:"strut bottom",style:{height:"0.68333em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.22222em"}},"Y"),s("span",{class:"mrel"},"="),s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit"},"x")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])]),a(" 大小的字母都表示曲线上的点,小写字母表示大整数 另外需要知道在ECDSA中: 1.如果一个整数乘以一个点,实际上表示出来就是指数,比如x*B="),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"B"),s("mi",null,"x")])]),s("annotation",{encoding:"application/x-tex"},"B^x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.68333em"}}),s("span",{class:"strut bottom",style:{height:"0.68333em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit"},"x")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])]),a(" 2. 两个点相减则表示除法,比如H-B="),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mfrac",null,[s("mi",null,"H"),s("mi",null,"B")])]),s("annotation",{encoding:"application/x-tex"},"\\frac H B")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.872331em"}}),s("span",{class:"strut bottom",style:{height:"1.217331em","vertical-align":"-0.345em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord reset-textstyle textstyle uncramped"},[s("span",{class:"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist"},[s("span",{style:{top:"0.345em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle cramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.05017em"}},"B")])]),s("span",{style:{top:"-0.22999999999999998em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle textstyle uncramped frac-line"})]),s("span",{style:{top:"-0.394em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.08125em"}},"H")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])]),s("span",{class:"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"})])])])])],-1),y=n(`<h3 id="_3-2-生成过程" tabindex="-1">3.2 生成过程 <a class="header-anchor" href="#_3-2-生成过程" aria-label="Permalink to &quot;3.2 生成过程&quot;">​</a></h3><p>也就是证明方按照生成一个随机数,并给出证明,这个随机数就是按照我们确定的规则生成的.</p><h4 id="_3-2-1-h1-把任意信息映射到曲线上的点" tabindex="-1">3.2.1 H1:把任意信息映射到曲线上的点 <a class="header-anchor" href="#_3-2-1-h1-把任意信息映射到曲线上的点" aria-label="Permalink to &quot;3.2.1 H1:把任意信息映射到曲线上的点&quot;">​</a></h4><p>思路也很简单,将Hash(m)(<strong>注意是256位hash</strong>)作为曲线上的X,然后带入上述椭圆曲线公式,求出相应的Y即可. 具体对应代码中就是<code>hash_to_curve</code></p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">    //self是私钥,alpha就是VRF的输入源</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F78C6C;">pub</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">super</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hash_to_curve</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> alpha</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;[</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">EdwardsPoint</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">mut</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">32</span><span style="color:#89DDFF;">];</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">mut</span><span style="color:#A6ACCD;"> counter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">mut</span><span style="color:#A6ACCD;"> wrapped_point</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Option</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">EdwardsPoint</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">None</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> wrapped_point</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">is_none</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            result</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">copy_from_slice</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">&amp;</span><span style="color:#FFCB6B;">Sha512</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">new</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(&amp;[</span><span style="color:#A6ACCD;">SUITE</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ONE</span><span style="color:#89DDFF;">])</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">as_bytes</span><span style="color:#89DDFF;">())</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">alpha</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(&amp;[</span><span style="color:#A6ACCD;">counter</span><span style="color:#89DDFF;">])</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">result</span><span style="color:#89DDFF;">()[..</span><span style="color:#F78C6C;">32</span><span style="color:#89DDFF;">],</span><span style="color:#676E95;font-style:italic;"> //这里用的是sha512,但是只取了前半部分,因此是256位</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            wrapped_point </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CompressedEdwardsY</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">from_slice</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">result</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">decompress</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">            counter </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        wrapped_point</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unwrap</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">mul_by_cofactor</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="_3-2-2-h2-将一系列点hash为一个大整数" tabindex="-1">3.2.2 H2: 将一系列点Hash为一个大整数 <a class="header-anchor" href="#_3-2-2-h2-将一系列点hash为一个大整数" aria-label="Permalink to &quot;3.2.2 H2: 将一系列点Hash为一个大整数&quot;">​</a></h4><p>这个就更简单了,将这些点序列化,然后Hash,就得到一个大整数. 只是需要注意的是这个大整数需要模上曲线的阶.</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">pub</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">super</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hash_points</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">points</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;[</span><span style="color:#FFCB6B;">EdwardsPoint</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;"> ed25519_Scalar </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">mut</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">32</span><span style="color:#89DDFF;">];</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">mut</span><span style="color:#A6ACCD;"> hash </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Sha512</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">new</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(&amp;[</span><span style="color:#A6ACCD;">SUITE</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TWO</span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> point </span><span style="color:#F78C6C;">in</span><span style="color:#A6ACCD;"> points</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">iter</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        hash </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> hash</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">point</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">compress</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">to_bytes</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    result</span><span style="color:#89DDFF;">[..</span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">].</span><span style="color:#82AAFF;">copy_from_slice</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">hash</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">result</span><span style="color:#89DDFF;">()[..</span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#A6ACCD;">    ed25519_Scalar</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">from_bits</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">result</span><span style="color:#89DDFF;">)</span><span style="color:#676E95;font-style:italic;"> //这里实际上对基点就是取模</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="_3-2-3-ecvrf-nonce-generation" tabindex="-1">3.2.3 ECVRF_nonce_generation <a class="header-anchor" href="#_3-2-3-ecvrf-nonce-generation" aria-label="Permalink to &quot;3.2.3 ECVRF_nonce_generation&quot;">​</a></h4><p>根据私钥和待签名信息导出一个确定的大整数. 这里的nonce是从私钥推导出来的,h_point则是下文中用到的H.</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">pub</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">super</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">nonce_generation_bytes</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">nonce</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">32</span><span style="color:#89DDFF;">],</span><span style="color:#A6ACCD;"> h_point</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">EdwardsPoint</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">64</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">mut</span><span style="color:#A6ACCD;"> k_buf </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">64</span><span style="color:#89DDFF;">];</span></span>
<span class="line"><span style="color:#A6ACCD;">    k_buf</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">copy_from_slice</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&amp;</span><span style="color:#FFCB6B;">Sha512</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">new</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">nonce</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">chain</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">h_point</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">compress</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">as_bytes</span><span style="color:#89DDFF;">())</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">result</span><span style="color:#89DDFF;">()[..],</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">);</span><span style="color:#676E95;font-style:italic;"> //生成思路也很简单,就是Hash一下,就可以得到一个大整数</span></span>
<span class="line"><span style="color:#A6ACCD;">    k_buf</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="_3-2-4-生成随机数以及证明" tabindex="-1">3.2.4 生成随机数以及证明 <a class="header-anchor" href="#_3-2-4-生成随机数以及证明" aria-label="Permalink to &quot;3.2.4 生成随机数以及证明&quot;">​</a></h4> H=H1(\\alpha) \\\\ k=ECVRF\\_nonce\\_generation(SK,H) \\\\ \\Gamma =H^x \\\\ c=H2(H,\\Gamma,B^k,H^k) \\\\ s=k+cx `,13),D=s("p",null,[a("然后将Proof={"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Γ")]),s("annotation",{encoding:"application/x-tex"},"\\Gamma")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.68333em"}}),s("span",{class:"strut bottom",style:{height:"0.68333em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathrm"},"Γ")])])]),a(",c,s}发给验证方. 证明其实就是想证明我这里的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Γ"),s("mo",null,"="),s("msup",null,[s("mi",null,"H"),s("mi",null,"x")])]),s("annotation",{encoding:"application/x-tex"},"\\Gamma=H^x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.68333em"}}),s("span",{class:"strut bottom",style:{height:"0.68333em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathrm"},"Γ"),s("span",{class:"mrel"},"="),s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.08125em"}},"H"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit"},"x")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])]),a(",而不是通过什么其他方式得到的.")],-1),F=n(`<div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/// A longer private key which is slightly optimized for proof generation.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">///</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/// This is similar in structure to ed25519_dalek::ExpandedSecretKey. It can be produced from</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/// a VRFPrivateKey.</span></span>
<span class="line"><span style="color:#F78C6C;">pub</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">VRFExpandedPrivateKey</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F78C6C;">pub</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">super</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> ed25519_Scalar</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F78C6C;">pub</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">super</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> nonce</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">32</span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/// Produces a proof for an input (using the expanded private key)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F78C6C;">pub</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">prove</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> pk</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#FFCB6B;">VRFPublicKey</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> alpha</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;[</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Proof</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> h_point </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> pk</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hash_to_curve</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">alpha</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //k实际上是一个随机数,这里采用RFC6979中的规则是为了让每次生成的proof都完全一样,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        // 比特币以太坊签名中也是这么使用的. 但是如果你非要用一个随机数,别人也没办法,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        // 并且完全行得通</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> k_scalar </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">            ed25519_Scalar</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">from_bytes_mod_order_wide</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#82AAFF;">nonce_generation_bytes</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">nonce</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> h_point</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //nonce由私钥hash后生成,可以认为私钥确定了,nonce就确定了,而h_point和签名中的用法是一样的,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        // 就是待签名信息        因此原文中共识是这样的:k = ECVRF_nonce_generation(SK,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        // h_string)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //Gamma = x*H</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> gamma </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> h_point </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //        c = ECVRF_hash_points(H, Gamma, k*B, k*H)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> c_scalar </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hash_points</span><span style="color:#89DDFF;">(&amp;[</span></span>
<span class="line"><span style="color:#A6ACCD;">            h_point</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">            gamma</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">            ED25519_BASEPOINT_POINT </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> k_scalar</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">            h_point </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> k_scalar</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //s = (k + c*x) mod q</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //proof={gama,c,s}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#FFCB6B;">Proof</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            gamma</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;"> //这也是VRF生成的随机数</span></span>
<span class="line"><span style="color:#A6ACCD;">            c</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> c_scalar</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">            s</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> k_scalar </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> c_scalar </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>需要补充说明的是验证方不可能知道:</p>`,2),m=s("ol",null,[s("li",null,"私钥也就是x"),s("li",null,[a("k,这是证明方用ECVRF_nonce_generation生成的 虽然随机数用"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Γ")]),s("annotation",{encoding:"application/x-tex"},"\\Gamma")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.68333em"}}),s("span",{class:"strut bottom",style:{height:"0.68333em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathrm"},"Γ")])])]),a("也就是曲线上的一个点来表示,但是很容易通过Hash计算转换成一个大整数")])],-1),A=s("h3",{id:"_3-3-验证的过程",tabindex:"-1"},[a("3.3 验证的过程 "),s("a",{class:"header-anchor",href:"#_3-3-验证的过程","aria-label":'Permalink to "3.3 验证的过程"'},"​")],-1),C=s("p",null,"已知信息:",-1),u=s("ol",null,[s("li",null,"Y:公钥"),s("li",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",null,"α")]),s("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.43056em"}}),s("span",{class:"strut bottom",style:{height:"0.43056em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.0037em"}},"α")])])]),a(":VRF输入源")]),s("li",null,[a("Proof:{"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Γ")]),s("annotation",{encoding:"application/x-tex"},"\\Gamma")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.68333em"}}),s("span",{class:"strut bottom",style:{height:"0.68333em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathrm"},"Γ")])])]),a(",c,s}")])],-1),h=a(" H=H1(\\alpha) \\\\ U=\\frac {B^s} {Y^c} \\\\ V=\\frac {H^s} {\\Gamma^c} \\\\ c'=H2(H,\\Gamma,U,V) "),b=s("p",null,[s("strong",null,[a("如果c'和c相等,则认可"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Γ")]),s("annotation",{encoding:"application/x-tex"},"\\Gamma")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.68333em"}}),s("span",{class:"strut bottom",style:{height:"0.68333em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord mathrm"},"Γ")])])]),a("就是证明方按照规则生产的随机数.")])],-1),d=s("p",null,"这里在计算c'和证明方计算c的过程不一样的对方只有两处:",-1),_=s("ol",null,[s("li",null,[a("用U来代替了"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"B"),s("mi",null,"k")])]),s("annotation",{encoding:"application/x-tex"},"B^k")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.849108em"}}),s("span",{class:"strut bottom",style:{height:"0.849108em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.03148em"}},"k")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])]),a(",")]),s("li",null,[a("用V代替了"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"H"),s("mi",null,"k")])]),s("annotation",{encoding:"application/x-tex"},"H^k")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.849108em"}}),s("span",{class:"strut bottom",style:{height:"0.849108em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.08125em"}},"H"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.03148em"}},"k")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])])])],-1),f=s("p",null,"接下来我们要证明,两者都是相等的.",-1),g=s("h4",{id:"_3-3-1-证明u",tabindex:"-1"},[a("3.3.1 证明U="),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"B"),s("mi",null,"k")])]),s("annotation",{encoding:"application/x-tex"},"B^k")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.849108em"}}),s("span",{class:"strut bottom",style:{height:"0.849108em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.03148em"}},"k")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])]),a(),s("a",{class:"header-anchor",href:"#_3-3-1-证明u","aria-label":'Permalink to "3.3.1 证明U=$B^k$"'},"​")],-1),x=n(`<div class="language-tex line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tex</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">U=</span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {B^s} {Y^c} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> =</span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {B^{k+cx}} {Y^c} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> =</span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {B^{k+cx}} {{B^x}^c} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> =</span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {B^{k+cx}} {B^{cx}} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> =B^k</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img alt="image-20230330105631137" data-src="./img/image-20230330105631137.png" loading="lazy" class="lazy"></p>`,2),k=s("h4",{id:"_3-3-2-证明v",tabindex:"-1"},[a("3.3.2 证明V="),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"H"),s("mi",null,"k")])]),s("annotation",{encoding:"application/x-tex"},"H^k")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.849108em"}}),s("span",{class:"strut bottom",style:{height:"0.849108em","vertical-align":"0em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord"},[s("span",{class:"mord mathit",style:{"margin-right":"0.08125em"}},"H"),s("span",{class:"vlist"},[s("span",{style:{top:"-0.363em","margin-right":"0.05em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.03148em"}},"k")])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),a("​")])])])])])]),a(),s("a",{class:"header-anchor",href:"#_3-3-2-证明v","aria-label":'Permalink to "3.3.2 证明V=$H^k$"'},"​")],-1),E=n(`<div class="language-tex line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tex</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">V=</span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {H^s} {</span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">Gamma</span><span style="color:#A6ACCD;">^c} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> = </span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {H^{k+cx}} {</span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">Gamma</span><span style="color:#A6ACCD;">^c} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> = </span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {H^{k+cx}} {{H^x}^c} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> = </span><span style="color:#89DDFF;">\\</span><span style="color:#82AAFF;">frac</span><span style="color:#A6ACCD;"> {H^{k+cx}} {H^{cx}} </span><span style="color:#89DDFF;font-style:italic;">\\\\</span></span>
<span class="line"><span style="color:#A6ACCD;"> = H^k</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img alt="image-20230330105656442" data-src="./img/image-20230330105656442.png" loading="lazy" class="lazy"></p><p>3.3.3 实现过程</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki material-theme-palenight"><code><span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/// An ECVRF public key</span></span>
<span class="line"><span style="color:#89DDFF;">#[</span><span style="color:#A6ACCD;">derive</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">Serialize</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Deserialize</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Deref</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Debug</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PartialEq</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Eq</span><span style="color:#89DDFF;">)]</span></span>
<span class="line"><span style="color:#F78C6C;">pub</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">VRFPublicKey</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ed25519_PublicKey</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> /// Given a [\`Proof\`] and an input, returns whether or not the proof is valid for the input</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /// and public key</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F78C6C;">pub</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">verify</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> proof</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#FFCB6B;">Proof</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> alpha</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;[</span><span style="color:#FFCB6B;">u8</span><span style="color:#89DDFF;">])</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Result</span><span style="color:#89DDFF;">&lt;()&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //同样将已知的确定信息alpha映射到H点</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> h_point </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> self</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hash_to_curve</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">alpha</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //PK:是公钥</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> pk_point </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CompressedEdwardsY</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">from_slice</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">as_bytes</span><span style="color:#89DDFF;">())</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">decompress</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unwrap</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //c&#39; = ECVRF_hash_points(H, Gamma, U, V)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> cprime </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hash_points</span><span style="color:#89DDFF;">(&amp;[</span></span>
<span class="line"><span style="color:#A6ACCD;">            h_point</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">            proof</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">gamma</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">            ED25519_BASEPOINT_POINT </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> proof</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">s </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> pk_point </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> proof</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;"> //U=s*B - c*Y</span></span>
<span class="line"><span style="color:#A6ACCD;">            h_point </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> proof</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">s </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> proof</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">gamma </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> proof</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">              //V= s*H - c*Gamma</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        //相等则有效,不等则无效</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> proof</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">c </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> cprime </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#FFCB6B;">Ok</span><span style="color:#89DDFF;">(())</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#82AAFF;">bail!</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">The proof failed to verify for this public key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="_4-结束语" tabindex="-1">4. 结束语 <a class="header-anchor" href="#_4-结束语" aria-label="Permalink to &quot;4. 结束语&quot;">​</a></h2><p>VRF是一个好东西,给区块链带来了可预测的伪随机性. 不过在Libra中号称自己使用了VRF,并且也在代码中看到了实现.就是没有找到使用的地方,可能是我的找法不对? 我看的代码版本是<a href="https://github.com/libra/libra/tree/d324ce75cc9bcc6777a2b45c756f4df2f47c4ef3/crypto" target="_blank" rel="noreferrer">d324ce75cc9bcc6777a2b45c756f4df2f47c4ef3</a></p>`,6),B=[t,r,c,i,y,D,F,m,A,C,u,h,b,d,_,f,g,x,k,E];function z(v,P,S,V,H,T){return e(),p("div",null,B)}const K=l(o,[["render",z]]);export{R as __pageData,K as default};
