import{_ as a,c as s,o as n,N as l}from"./chunks/framework.3a9190c5.js";const d=JSON.parse('{"title":"bloom","description":"","frontmatter":{"title":"bloom","date":"2018-11-11T10:40:47.000Z","draft":false,"markup":"mmark"},"headers":[],"relativePath":"blockchain/btcd/bloom.md"}'),e={name:"blockchain/btcd/bloom.md"},o=l(`<h1 id="btcutil-bloom-代码阅读" tabindex="-1">btcutil/bloom 代码阅读 <a class="header-anchor" href="#btcutil-bloom-代码阅读" aria-label="Permalink to &quot;btcutil/bloom 代码阅读&quot;">​</a></h1><h2 id="murmurhash3-介绍" tabindex="-1">MurmurHash3 介绍 <a class="header-anchor" href="#murmurhash3-介绍" aria-label="Permalink to &quot;MurmurHash3 介绍&quot;">​</a></h2><p>这里的bloom过滤器用到了一个和平时不一样的hash算法,就是MurmurHash,以下来自<a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noreferrer">Murmur维基百科</a>,</p><p>MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。 由Austin Appleby在2008年发明， 并出现了多个变种， 都已经发布到了公有领域(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好</p><p>特点: 速度快 分布良好</p><p>适用于,比如Map的key之类的</p><p>MurmurHash3 这里固定生成一个32位整数,</p><p>注意他与MD5,SHA3等目标完全不同,不抗攻击,因为结果只有32位,所以是不抗碰撞的.</p><h2 id="filter的工作原理" tabindex="-1">Filter的工作原理 <a class="header-anchor" href="#filter的工作原理" aria-label="Permalink to &quot;Filter的工作原理&quot;">​</a></h2><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Filter</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	mtx           sync</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Mutex</span></span>
<span class="line"><span style="color:#A6ACCD;">	msgFilterLoad </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">wire</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MsgFilterLoad</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MsgFilterLoad</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	Filter    </span><span style="color:#89DDFF;">[]</span><span style="color:#C792EA;">byte</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//bloom数据存储位置</span></span>
<span class="line"><span style="color:#A6ACCD;">	HashFuncs </span><span style="color:#C792EA;">uint32</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//进行多少轮hash</span></span>
<span class="line"><span style="color:#A6ACCD;">	Tweak     </span><span style="color:#C792EA;">uint32</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//一个随机数</span></span>
<span class="line"><span style="color:#A6ACCD;">	Flags     BloomUpdateType</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="添加数据-add" tabindex="-1">添加数据 Add <a class="header-anchor" href="#添加数据-add" aria-label="Permalink to &quot;添加数据 Add&quot;">​</a></h3><ol><li>将数据+第i轮+Tweak 使用MurmurHash3做hash值得到一个32位整数,然后取模Fiter的长度, 2 ) 得到数据映射位置</li><li>因为一个位置里面有8位,那么映射的那一位就是1&lt;&lt;7&amp;hash值</li></ol><p>整体来说只是一个挺巧妙的bloom方法,</p><h3 id="校验数据是否存在bloom过滤器中" tabindex="-1">校验数据是否存在bloom过滤器中 <a class="header-anchor" href="#校验数据是否存在bloom过滤器中" aria-label="Permalink to &quot;校验数据是否存在bloom过滤器中&quot;">​</a></h3><p>方法和Add几乎一样,相应的位置是1,就表明有. 同样进行HashFuncs轮校验,每轮得到的位置都是1,表明数据存在.</p><h3 id="bloom过滤器" tabindex="-1">bloom过滤器 <a class="header-anchor" href="#bloom过滤器" aria-label="Permalink to &quot;bloom过滤器&quot;">​</a></h3><p>只能起到否定存在的作用,校验结果不存在,那数据一定不在这里. 如果存在,则未必就真存在. 需要再次确认.</p>`,17),p=[o];function r(t,c,i,m,b,u){return n(),s("div",null,p)}const y=a(e,[["render",r]]);export{d as __pageData,y as default};
