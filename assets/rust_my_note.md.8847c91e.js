import{o as n,c as s,e as a}from"./app.8bf2a359.js";const e='{"title":"rust学习笔记","description":"","frontmatter":{"title":"rust学习笔记","date":"2019-04-03T03:57:03.000Z","draft":false,"tags":["rust"],"categories":["技术相关"]},"headers":[{"level":2,"title":"内存安全","slug":"内存安全"},{"level":3,"title":"段错误","slug":"段错误"},{"level":2,"title":"所有权","slug":"所有权"},{"level":2,"title":"借用于所有权","slug":"借用于所有权"},{"level":3,"title":"Copy Trait","slug":"copy-trait"},{"level":3,"title":"Copy和Clone的区别","slug":"copy和clone的区别"},{"level":3,"title":"引用与解引用(dereferencing)","slug":"引用与解引用-dereferencing"},{"level":3,"title":"Slice类型","slug":"slice类型"},{"level":2,"title":"结构体","slug":"结构体"},{"level":3,"title":"struct","slug":"struct"},{"level":2,"title":"枚举","slug":"枚举"},{"level":2,"title":"crate,mod","slug":"crate-mod"},{"level":2,"title":"rust高级部分","slug":"rust高级部分"},{"level":3,"title":"unsafe","slug":"unsafe"},{"level":2,"title":"Cell 用法","slug":"cell-用法"},{"level":3,"title":"借用规则","slug":"借用规则"},{"level":3,"title":"解引用","slug":"解引用"},{"level":3,"title":"宏","slug":"宏"},{"level":3,"title":"临时变量的生命周期","slug":"临时变量的生命周期"},{"level":3,"title":"\'static 泛型","slug":"static-泛型"},{"level":3,"title":"函数生命周期的推导规则","slug":"函数生命周期的推导规则"},{"level":3,"title":"高阶生命周期","slug":"高阶生命周期"},{"level":2,"title":"宏","slug":"宏-1"},{"level":3,"title":"宏调试","slug":"宏调试"},{"level":3,"title":"关于线程安全","slug":"关于线程安全"},{"level":2,"title":"关于async和await","slug":"关于async和await"},{"level":3,"title":"await","slug":"await"},{"level":3,"title":"Pinning","slug":"pinning"},{"level":3,"title":"Stream","slug":"stream"},{"level":2,"title":"atmoic","slug":"atmoic"},{"level":3,"title":"Release-Acquire ordering","slug":"release-acquire-ordering"},{"level":3,"title":"Sized和?Sized","slug":"sized和-sized"},{"level":3,"title":"Borrow 和AsRef两个Trait的关系","slug":"borrow-和asref两个trait的关系"},{"level":2,"title":"PhantomData的一些用法","slug":"phantomdata的一些用法"}],"relativePath":"rust/my_note.md","lastUpdated":1641139108747}',p={},t=[a('<h2 id="内存安全"><a class="header-anchor" href="#内存安全" aria-hidden="true">#</a> 内存安全</h2><h3 id="段错误"><a class="header-anchor" href="#段错误" aria-hidden="true">#</a> 段错误</h3><p>Rust is a systems programming language that runs blazingly fast，prevents segfaults，and guarantees thread safety.</p><p>内存不安全的行为:</p><ul><li>空指针</li><li>野指针</li><li>悬空指针</li><li>使用未初始化的指针</li><li>非法释放</li><li>缓冲区溢出</li><li>执行非法函数指针</li><li>数据竞争</li></ul><p>不认为是内存安全的行为:</p><ul><li>内存泄漏</li></ul><h2 id="所有权"><a class="header-anchor" href="#所有权" aria-hidden="true">#</a> 所有权</h2><ol><li>Rust 中的每一个值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol><h2 id="借用于所有权"><a class="header-anchor" href="#借用于所有权" aria-hidden="true">#</a> 借用于所有权</h2><ol><li>一个变量可以存在多个只读借用(shared reference),但是实际上又可以有其他手段来修改</li><li>一个变量只能存在一个可写借用,可写借用可以修改变量的内容,但是不能转移所有权</li></ol><h3 id="copy-trait"><a class="header-anchor" href="#copy-trait" aria-hidden="true">#</a> Copy Trait</h3><p>编译时大小已知,并且存储在栈上(值类型)一般都有copy trait,称之为浅拷贝.</p><ul><li>元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。</li></ul><h3 id="copy和clone的区别"><a class="header-anchor" href="#copy和clone的区别" aria-hidden="true">#</a> Copy和Clone的区别</h3><p>Copy是浅拷贝,是编译器自动调用,Clone是深拷贝,程序员手工调用.</p><h3 id="引用与解引用-dereferencing"><a class="header-anchor" href="#引用与解引用-dereferencing" aria-hidden="true">#</a> 引用与解引用(dereferencing)</h3><p>&amp; 引用实际上可以认为是所有权的临时借用 (不全是c语言中的指针,只不过用起来像而已)</p><ul><li>解引用</li></ul><p>引用有两种 <strong>不可变引用与可变引用</strong>.</p><ul><li>在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。</li><li>引用必须总是有效。</li></ul><h3 id="slice类型"><a class="header-anchor" href="#slice类型" aria-hidden="true">#</a> Slice类型</h3><ul><li>他没有数据所有权</li><li>他只是对堆上数据的引用</li></ul><h2 id="结构体"><a class="header-anchor" href="#结构体" aria-hidden="true">#</a> 结构体</h2><h3 id="struct"><a class="header-anchor" href="#struct" aria-hidden="true">#</a> struct</h3><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">{</span>\n    username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>\n    email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>\n    sign_in_count<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span>\n    active<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol><li>#[drive(Debug)] 可以方便打印调试信息 {:?}</li><li>定义在结构体上的函数称之为方法 (第一个参数是&amp;self或者&amp;mut self)</li><li>&amp;self(&amp; mut self) 类似于this指针</li><li>关联函数,定义在struct上,但是第一个参数不是&amp;self(类似于c++类的静态函数)</li></ol><p>###元组(tuple) 元组是没有字段名的结构体</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">struct</span> <span class="token type-definition class-name">Color</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="枚举"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h2><p>枚举是一个很多语言都有的功能，不过不同语言中其功能各不相同。Rust 的枚举与 F#、OCaml 和 Haskell 这样的函数式编程语言中的 代数数据类型（algebraic data types）最为相似。</p><p><strong>与C/go语言中的枚举完全不同,没有对应的整数值.</strong></p><p>一个典型的例子:</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Quit</span><span class="token punctuation">,</span>\n    <span class="token class-name">Move</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="option"><a class="header-anchor" href="#option" aria-hidden="true">#</a> Option</h4><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token class-name">None</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>match必须是穷尽的</strong></p><p><strong>if let是一种专门的用法</strong></p><h2 id="crate-mod"><a class="header-anchor" href="#crate-mod" aria-hidden="true">#</a> crate,mod</h2><ul><li>模块，一个组织代码和控制路径私有性的方式</li><li>路径，一个命名项（item）的方式</li><li>use 关键字用来将路径引入作用域,super关键字表示父模块</li><li>pub 关键字使项变为公有</li><li>as 关键字用于将项引入作用域时进行重命名</li><li>使用外部包</li><li>嵌套路径用来消除大量的 use 语句</li><li>使用 glob 运算符将模块的所有内容引入作用域</li><li>如何将不同模块分割到单独的文件中</li></ul><ul><li>通过pub use重导出</li><li>通过cargo.toml中[dependencies]来使用外部包</li></ul><h2 id="rust高级部分"><a class="header-anchor" href="#rust高级部分" aria-hidden="true">#</a> rust高级部分</h2><h3 id="unsafe"><a class="header-anchor" href="#unsafe" aria-hidden="true">#</a> unsafe</h3><ul><li>解引用裸指针</li><li>调用不安全的函数或方法</li><li>访问或修改可变静态变量</li><li>实现不安全 trait 如果不必要使用unsafe的时候用了unsfae关键字也会错误,也就是说没有出现上述四种情况,但是用了unsafe.</li></ul><h2 id="cell-用法"><a class="header-anchor" href="#cell-用法" aria-hidden="true">#</a> Cell 用法</h2><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">Cell</span><span class="token punctuation">;</span>\n\n<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n<span class="token keyword">let</span> data <span class="token punctuation">:</span> <span class="token class-name">Cell</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">Cell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>data<span class="token punctuation">;</span> vdata<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\np<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>所谓的内部可变性,就是不用mut,一样可以修改Cell包括的内容. cell导出接口</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Cell</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">//这个要求是可写借用,其他都是只读借用,但是还是可以修改其内容</span>\n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">T</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> \n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">replace</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">into_inner</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token comment">//Copy实际上就是get</span>\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span><span class="token class-name">Copy</span><span class="token operator">&gt;</span> <span class="token class-name">Cell</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> \n    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>RefCell接口的定义</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token class-name">Sized</span><span class="token operator">&gt;</span> <span class="token class-name">RefCell</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n\n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Ref</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> \n<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">try_borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Ref</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span><span class="token class-name">BorrowError</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">borrow_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">RefMut</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> \n <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">try_borrow_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">RefMut</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">BorrowMutError</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n     <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">T</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>他和cell不一样的是,他并不能直接修改或者读取其包含的内容,而是通过borrow以及borrow_mut来获取其对应的<code>Ref&lt;T&gt;</code>和<code>RefMut&lt;T&gt;</code></p><p>如何选择Cell和RefCell? 如果你只需要整体性地存⼊、取出T，那么就选 Cell。如果你需要有个可读写指针指向这个T修改它，那么就选RefCell。</p><h3 id="借用规则"><a class="header-anchor" href="#借用规则" aria-hidden="true">#</a> 借用规则</h3><ol><li>借用指针不能比它指向的变量存在更长的时间</li><li>&amp;mut型借用只能指向本身具有mut修饰的变量</li><li>&amp;mut型借用指针存在的时候,被借用变量出于冻结状态.</li><li>&amp;型借用和&amp;mut型借用互斥,不可同时存在.</li><li>最多同时存在一个&amp;mut型借用</li><li>可以存在在没有&amp;mut型借用的情况下,存在多个&amp;型借用.</li></ol><h3 id="解引用"><a class="header-anchor" href="#解引用" aria-hidden="true">#</a> 解引用</h3><p>Rust会自动解引用,这看起来就像类型自动转换一样. 比如<code>Vec&lt;T&gt;</code>实现了deref 因此<code>&amp;Vec&lt;T&gt;</code>即可以当做&amp;[T]来用,当然也可以当做</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span>\n\n<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个例子中s类型为<code>Rc&lt;T&gt;</code>并没有bytes函数,Rust会自动解引用,得到str类型,然后调用上面的bytes函数. 这个过程是这样的</p><ol><li>尝试Rc::bytes(&amp;s),不可行继续2</li><li>尝试String::bytes(Rc::deref(&amp;s)),不可行,继续3</li><li>尝试str::bytes(String::deref(Rc::deref(&amp;s))),ok结束 实际执行的是<code>s.deref().deref().bytes()</code></li></ol><p>编译器会自动无限deref尝试,直到不能deref下去. <strong>如果不能自动判断,需要手工介入</strong></p><p>**&amp;***和&amp; * 是不一样的</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">let</span> s<span class="token operator">=</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>&amp;*s会被直接当成s.deref(),而不是*s先把内部数据移走然后去借用</p><h3 id="宏"><a class="header-anchor" href="#宏" aria-hidden="true">#</a> 宏</h3><h4 id="宏展开方法"><a class="header-anchor" href="#宏展开方法" aria-hidden="true">#</a> 宏展开方法</h4><div class="language-"><pre><code>cargo rustc -- -Z unstable-options --pretty=expanded\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="临时变量的生命周期"><a class="header-anchor" href="#临时变量的生命周期" aria-hidden="true">#</a> 临时变量的生命周期</h3><p>来自于这篇讨论<a href="https://stackoverflow.com/questions/47662253/why-is-it-legal-to-borrow-a-temporary" target="_blank" rel="noopener noreferrer">借用一个临时变量是有效的</a></p><div class="language-"><pre><code>Temporary lifetimes\n\nWhen using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>This applies, because String::new() is a value expression and being just below &amp;mut it is in a place expression context. Now the reference operator only has to pass through this temporary memory location, so it becomes the value of the whole right side (including the &amp;mut).</p><div class="language-"><pre><code>When a temporary value expression is being created that is assigned into a let declaration, however, the temporary is created with the lifetime of the enclosing block instead\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Since it is assigned to the variable it gets a lifetime until the end of the enclosing block.</p><p>This also answers this question about the difference between</p><div class="language-"><pre><code>let a = &amp;String::from(&quot;abcdefg&quot;); // ok!\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>and</p><div class="language-"><pre><code>let a = String::from(&quot;abcdefg&quot;).as_str(); // compile error 这样之所以不行是因为as_str()借用的生命周期和a相同,但是被借用对象string::from()返回的临时变量的生命周期依然是这一行\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>In the second variant the temporary is passed into as_str(), so its lifetime ends at the end of the statement.</p><p>通俗来说,就是临时变量的生命周期就是这一行语句,但是如果返回的变量使用let绑定的话,那么其生命周期就变成了最近的那个{}</p><h3 id="static-泛型"><a class="header-anchor" href="#static-泛型" aria-hidden="true">#</a> &#39;static 泛型</h3><p>若是有where T：&#39;static 的约束，意思则是，类型T⾥⾯不包含任何指向短⽣命周期的借⽤指针， 意思是要么完全不包含任何借⽤，要么可以有指向&#39;static的借⽤指针。</p><h3 id="函数生命周期的推导规则"><a class="header-anchor" href="#函数生命周期的推导规则" aria-hidden="true">#</a> 函数生命周期的推导规则</h3><ul><li>每个带⽣命周期参数的输⼊参数，每个对应不同的⽣命周期参数；</li><li>如果只有⼀个输⼊参数带⽣命周期参数，那么返回值的⽣命周期被指 定为这个参数；</li><li>如果有多个输⼊参数带⽣命周期参数，但其中有&amp;self、&amp;mut self， 那么返回值的⽣命周期被指定为这个参数；</li><li>以上都不满⾜，就不能⾃动补全返回值的⽣命周期参数</li></ul><h3 id="高阶生命周期"><a class="header-anchor" href="#高阶生命周期" aria-hidden="true">#</a> 高阶生命周期</h3><p>到⽬前为 ⽌，<code>for&lt;&#39;a&gt;Fn（&amp;&#39;a Arg）-&gt;&amp;&#39;a Ret</code>这样的语法，只能⽤于⽣命周期参数， 不能⽤于任意泛型类型。</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">fn</span> <span class="token function-definition function">calc_by</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span> <span class="token class-name">F</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>var<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token keyword">where</span> <span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token keyword">for</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;f</span><span class="token operator">&gt;</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;f</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> local <span class="token operator">=</span> <span class="token operator">*</span>var<span class="token punctuation">;</span>\n    <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="宏-1"><a class="header-anchor" href="#宏-1" aria-hidden="true">#</a> 宏</h2><p>Captures are written as a dollar ($) followed by an identifier, a colon (😃, and finally the kind of capture, which must be one of the following:</p><ul><li><p>item: an item, like a function, struct, module, etc.</p></li><li><p>block: a block (i.e. a block of statements and/or an expression, surrounded by braces)</p></li><li><p>stmt: a statement</p></li><li><p>pat: a pattern</p></li><li><p>expr: an expression</p></li><li><p>ty: a type</p></li><li><p>ident: an identifier</p></li><li><p>path: a path (e.g. foo, ::std::mem::replace, <code>transmute::&lt;_, int&gt;</code>, …)</p></li><li><p>meta: a meta item; the things that go inside #[...] and #![...] attributes</p></li><li><p>tt: a single token tree</p></li><li><p>item: anything.</p></li><li><p>block: anything.</p></li><li><p>stmt: =&gt; , ;</p></li><li><p>pat: =&gt; , = if in</p></li><li><p>expr: =&gt; , ;</p></li><li><p>ty: , =&gt; : = &gt; ; as</p></li><li><p>ident: anything.</p></li><li><p>path: , =&gt; : = &gt; ; as</p></li><li><p>meta: anything.</p></li><li><p>tt: anything.</p></li></ul><h3 id="宏调试"><a class="header-anchor" href="#宏调试" aria-hidden="true">#</a> 宏调试</h3><h4 id="_1-trace-macros"><a class="header-anchor" href="#_1-trace-macros" aria-hidden="true">#</a> 1. trace_macros</h4><p>trace_macros!(true); 设置以后能够将宏展开, 打印每一个步骤. trace_macros!(false); 停止打印</p><h4 id="_2-log-syntax"><a class="header-anchor" href="#_2-log-syntax" aria-hidden="true">#</a> 2. log_syntax!</h4><p>此宏能够在终端打印传递给他的每一个token,方便调试</p><h4 id="_3-宏展开"><a class="header-anchor" href="#_3-宏展开" aria-hidden="true">#</a> 3. 宏展开</h4><p>rustc -Z unstable-options --pretty expanded <a href="http://hello.rs" target="_blank" rel="noopener noreferrer">hello.rs</a></p><h3 id="关于线程安全"><a class="header-anchor" href="#关于线程安全" aria-hidden="true">#</a> 关于线程安全</h3><h4 id="send-sync"><a class="header-anchor" href="#send-sync" aria-hidden="true">#</a> send &amp;&amp; Sync</h4><p>Rust提供了Send和Sync两个标签trait，它们是Rust⽆数据竞争并发的基⽯。</p><ul><li>实现了Send的类型，可以安全地在线程间传递值，也就是说可以跨线程传递所有权。</li><li>实现了Sync的类型，可以跨线程安全地传递共享（不可变）引⽤(&amp;T)。 典型的没有实现Sync的例子: Cell和RefCell (多个线程同时读会有问题) 典型的没有实现Send的例子: Rc</li></ul><h2 id="关于async和await"><a class="header-anchor" href="#关于async和await" aria-hidden="true">#</a> 关于async和await</h2><h3 id="await"><a class="header-anchor" href="#await" aria-hidden="true">#</a> await</h3><p>如果Executor是多线程的,那么每一个.await都可能引发任务在不同线程之间发送 因此任务必须实现Send+Sync</p><p>Similarly, it isn&#39;t a good idea to hold a traditional non-futures-aware lock across an .await, as it can cause the threadpool to lock up: one task could take out a lock, .await and yield to the executor, allowing another task to attempt to take the lock and cause a deadlock. To avoid this, use the Mutex in futures::lock rather than the one from std::sync.</p><p>在Excutor中也是不适宜使用普通的lock,要使用futures提供的锁</p><h4 id="await和await代码的翻译"><a class="header-anchor" href="#await和await代码的翻译" aria-hidden="true">#</a> await和await代码的翻译</h4><p>一个简单的例子,不考虑复杂的</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">let</span> fut_one <span class="token operator">=</span> <span class="token punctuation">...</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> fut_two <span class="token operator">=</span> <span class="token punctuation">...</span><span class="token punctuation">;</span>\n<span class="token keyword">async</span> <span class="token keyword">move</span> <span class="token punctuation">{</span>\n    fut_one<span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>\n    fut_two<span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这段代码最终会被翻译成如下:</p><div class="language-rust line-numbers-mode"><pre><code>\n<span class="token comment">// The `Future` type generated by our `async { ... }` block</span>\n<span class="token keyword">struct</span> <span class="token type-definition class-name">AsyncFuture</span> <span class="token punctuation">{</span>\n    fut_one<span class="token punctuation">:</span> <span class="token class-name">FutOne</span><span class="token punctuation">,</span>\n    fut_two<span class="token punctuation">:</span> <span class="token class-name">FutTwo</span><span class="token punctuation">,</span>\n    state<span class="token punctuation">:</span> <span class="token class-name">State</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// List of states our `async` block can be in</span>\n<span class="token keyword">enum</span> <span class="token type-definition class-name">State</span> <span class="token punctuation">{</span>\n    <span class="token class-name">AwaitingFutOne</span><span class="token punctuation">,</span>\n    <span class="token class-name">AwaitingFutTwo</span><span class="token punctuation">,</span>\n    <span class="token class-name">Done</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span> <span class="token class-name">Future</span> <span class="token keyword">for</span> <span class="token class-name">AsyncFuture</span> <span class="token punctuation">{</span>\n    <span class="token keyword">type</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;_</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">loop</span> <span class="token punctuation">{</span>\n            <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>state <span class="token punctuation">{</span>\n                <span class="token class-name">State</span><span class="token punctuation">::</span><span class="token class-name">AwaitingFutOne</span> <span class="token operator">=&gt;</span> <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>fut_one<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">..</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token class-name">State</span><span class="token punctuation">::</span><span class="token class-name">AwaitingFutTwo</span><span class="token punctuation">,</span>\n                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>\n                <span class="token punctuation">}</span>\n                <span class="token class-name">State</span><span class="token punctuation">::</span><span class="token class-name">AwaitingFutTwo</span> <span class="token operator">=&gt;</span> <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>fut_two<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">..</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token class-name">State</span><span class="token punctuation">::</span><span class="token class-name">Done</span><span class="token punctuation">,</span>\n                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>\n                <span class="token punctuation">}</span>\n                <span class="token class-name">State</span><span class="token punctuation">::</span><span class="token class-name">Done</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h3 id="pinning"><a class="header-anchor" href="#pinning" aria-hidden="true">#</a> Pinning</h3><p>Pin主要是给借用服务的&amp;T和&amp;mut T,确保被借用的对象不被移动.</p><p>借用的使用例子</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">async</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> read_into_buf_fut <span class="token operator">=</span> <span class="token function">read_into_buf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    read_into_buf_fut<span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这部分代码如何翻译呢?</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">struct</span> <span class="token type-definition class-name">ReadIntoBuf</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    buf<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// points to `x` below</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">struct</span> <span class="token type-definition class-name">AsyncFuture</span> <span class="token punctuation">{</span>\n    x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">;</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    read_into_buf_fut<span class="token punctuation">:</span> <span class="token class-name">ReadIntoBuf</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;what_lifetime</span><span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>关键问题是&amp;T本质上是一个指针,那么AsyncFuture随时可能被移动,那么ReadIntoBuf中的这个&amp;T指针肯定会失效 因此需要使用Pin来保存. Pin有几种<code>Pin&lt;&amp;mut T&gt;, Pin&lt;&amp;T&gt;, Pin&lt;Box&lt;T&gt;&gt;</code>,主要是确保对应的T不会被移动.</p><h3 id="stream"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> Stream</h3><p>理解Stream的一个关键就是,返回Ready,里面可能是Some,也可能是None,如果是None,表示Stream关闭了.</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">trait</span> <span class="token class-name">Stream</span> <span class="token punctuation">{</span>\n    <span class="token comment">/// The type of the value yielded by the stream.</span>\n    <span class="token keyword">type</span> <span class="token class-name">Item</span><span class="token punctuation">;</span>\n\n    <span class="token comment">/// Attempt to resolve the next item in the stream.</span>\n    <span class="token comment">/// Retuns `Poll::Pending` if not ready, `Poll::Ready(Some(x))` if a value</span>\n    <span class="token comment">/// is ready, and `Poll::Ready(None)` if the stream has completed.</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">poll_next</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;_</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>\n        <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Item</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">send_recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token constant">BUFFER_SIZE</span><span class="token punctuation">:</span> <span class="token keyword">usize</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token keyword">mut</span> tx<span class="token punctuation">,</span> <span class="token keyword">mut</span> rx<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token namespace">mpsc<span class="token punctuation">::</span></span><span class="token function">channel</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token constant">BUFFER_SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    tx<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    tx<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">drop</span><span class="token punctuation">(</span>tx<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// `StreamExt::next` is similar to `Iterator::next`, but returns a</span>\n    <span class="token comment">// type that implements `Future&lt;Output = Option&lt;T&gt;&gt;`.</span>\n    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rx<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rx<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">None</span><span class="token punctuation">,</span> rx<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="atmoic"><a class="header-anchor" href="#atmoic" aria-hidden="true">#</a> atmoic</h2><p>atomic Ordering总共有五种顺序</p><ol><li>排序一致性顺序: SeqCst。</li><li>自由顺序: Relaxed (感觉类似c语言中的volatile)</li><li>其他: Release,Acquire,AcqRel Rust支持的5种内存顺序与其底层的LLVM支持的内存顺序是一致的</li></ol><h3 id="release-acquire-ordering"><a class="header-anchor" href="#release-acquire-ordering" aria-hidden="true">#</a> Release-Acquire ordering</h3><p>在这种模型下，store()使用memory_order_release，而load()使用memory_order_acquire。这种模型有两种效果，第一种是可以限制 CPU 指令的重排：</p><p>在store()之前的所有读写操作，不允许被移动到这个store()的后面。 在load()之后的所有读写操作，不允许被移动到这个load()的前面。 参考<a href="https://senlinzhan.github.io/2017/12/04/cpp-memory-order/" target="_blank" rel="noopener noreferrer">理解 C++ 的 Memory Order</a></p><div class="language-cpp line-numbers-mode"><pre><code>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> ready<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    data <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                                       <span class="token comment">// A</span>\n    ready<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// B</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ready<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// C</span>\n        <span class="token punctuation">;</span>\n    <span class="token function">assert</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// never failed              // D</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="memory-order-relaxed"><a class="header-anchor" href="#memory-order-relaxed" aria-hidden="true">#</a> memory_order_relaxed</h5><p>Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation&#39;s atomicity is guaranteed (see Relaxed ordering below)</p><h5 id="memory-order-consume"><a class="header-anchor" href="#memory-order-consume" aria-hidden="true">#</a> memory_order_consume</h5><p>A load operation with this memory order performs a consume operation on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see Release-Consume ordering below)</p><h5 id="memory-order-acquire"><a class="header-anchor" href="#memory-order-acquire" aria-hidden="true">#</a> memory_order_acquire</h5><p>A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)</p><h5 id="memory-order-release"><a class="header-anchor" href="#memory-order-release" aria-hidden="true">#</a> memory_order_release</h5><p>A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below).</p><h5 id="memory-order-acq-rel"><a class="header-anchor" href="#memory-order-acq-rel" aria-hidden="true">#</a> memory_order_acq_rel</h5><p>A read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</p><h5 id="memory-order-seq-cst"><a class="header-anchor" href="#memory-order-seq-cst" aria-hidden="true">#</a> memory_order_seq_cst</h5><p>A load operation with this memory order performs an acquire operation, a store performs a release operation, and read-modify-write performs both an acquire operation and a release operation, plus a single total order exists in which all threads observe all modifications in the same order (see Sequentially-consistent ordering below)</p><h3 id="sized和-sized"><a class="header-anchor" href="#sized和-sized" aria-hidden="true">#</a> Sized和?Sized</h3><p>?Sized对于T的约束主要是指可以是固定大小类型也可以说DST,对于DST来说,可以定义 但是用的时候只能是指针,比如下面的例子.</p><div class="language-rust line-numbers-mode"><pre><code><span class="token attribute attr-name">#[derive(Debug)]</span>\n<span class="token keyword">struct</span> <span class="token type-definition class-name">FooSized</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token punctuation">,</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token class-name">Sized</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n <span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">UnsafeCell</span><span class="token punctuation">;</span>\n\n<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> h_s  <span class="token operator">=</span> <span class="token class-name">FooSized</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> h_s<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> _s<span class="token operator">=</span><span class="token class-name">UnsafeCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>h_s<span class="token number">.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="borrow-和asref两个trait的关系"><a class="header-anchor" href="#borrow-和asref两个trait的关系" aria-hidden="true">#</a> Borrow 和AsRef两个Trait的关系</h3><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">AsRef</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token class-name">Sized</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">as_ref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">Borrow</span><span class="token operator">&lt;</span><span class="token class-name">Borrowed</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token class-name">Sized</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">Borrowed</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>从形式上看,他们是完全一样的,只是出于设计的目的不一样,不同的名字是让使用者在不同的场景下使用.</p><p>Choose Borrow when you want to abstract over different kinds of borrowing, or when you’re building a data structure that treats owned and borrowed values in equivalent ways, such as hashing and comparison.</p><p>Choose AsRef when you want to convert something to a reference directly, and you’re writing generic code.</p><h2 id="phantomdata的一些用法"><a class="header-anchor" href="#phantomdata的一些用法" aria-hidden="true">#</a> PhantomData的一些用法</h2><p>在看tokio的代码中发现的,</p><div class="language-rust line-numbers-mode"><pre><code><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">CachedParkThread</span> <span class="token punctuation">{</span>\n    _anchor<span class="token punctuation">:</span> <span class="token class-name">PhantomData</span><span class="token operator">&lt;</span><span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token comment">/// Used to ensure the invariants are respected</span>\n<span class="token keyword">struct</span> <span class="token type-definition class-name">GenerationGuard</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">&#39;a</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">/// Worker reference</span>\n    worker<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;a</span> <span class="token class-name">Worker</span><span class="token punctuation">,</span>\n\n    <span class="token comment">/// Prevent `Sync` access</span>\n    _p<span class="token punctuation">:</span> <span class="token class-name">PhantomData</span><span class="token operator">&lt;</span><span class="token class-name">Cell</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Enter</span> <span class="token punctuation">{</span>\n    _p<span class="token punctuation">:</span> <span class="token class-name">PhantomData</span><span class="token operator">&lt;</span><span class="token class-name">RefCell</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这里的用法目的是阻止Send,Sync的自动实现,防止这些结构体跨线程传递.</p>',150)];p.render=function(a,e,p,o,l,c){return n(),s("div",null,t)};export{e as __pageData,p as default};
