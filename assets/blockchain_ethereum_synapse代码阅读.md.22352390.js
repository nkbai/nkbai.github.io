import{_ as e,c as a,o as t,N as r}from"./chunks/framework.3a9190c5.js";const u=JSON.parse('{"title":"synapse代码阅读","description":"","frontmatter":{"title":"synapse代码阅读","date":"2018-10-22T13:09:09.000Z","draft":false,"markup":"mmark"},"headers":[],"relativePath":"blockchain/ethereum/synapse代码阅读.md"}'),i={name:"blockchain/ethereum/synapse代码阅读.md"},s=r('<h1 id="synapse代码阅读的一点体会" tabindex="-1">synapse代码阅读的一点体会 <a class="header-anchor" href="#synapse代码阅读的一点体会" aria-label="Permalink to &quot;synapse代码阅读的一点体会&quot;">​</a></h1><h2 id="homeserver中的get-xx找不到" tabindex="-1">HomeServer中的get_xx找不到 <a class="header-anchor" href="#homeserver中的get-xx找不到" aria-label="Permalink to &quot;HomeServer中的get_xx找不到&quot;">​</a></h2><p>实际上是通过setattr DEPENDENCIES动态设置的, 以federation_client为例. get_federation_client 是在初始化的时候通过<code>_make_dependency_method</code>构造的. _make_dependency_method最终会调用build_federation_client来构造实例,</p><p>至于为什么这么做,我猜可能是为了延迟实例初始化.避免不避免的构建.</p><h2 id="http服务的总入口" tabindex="-1">http服务的总入口 <a class="header-anchor" href="#http服务的总入口" aria-label="Permalink to &quot;http服务的总入口&quot;">​</a></h2><p>SynapseHomeServer的_listener_http关联到SynapseSite SynapseSite是按照twisted框架导出真实服务接口的地方.</p><p>SynapseHomeServer的_configure_named_resource是加载相应的resource的入口 在这里可以看到配置文件如何影响加载</p><p>ClientRestResource这是目前client-server api的总入口. TransportLayerServer这是fedoration 服务的总入口</p><h2 id="http模块" tabindex="-1">http模块 <a class="header-anchor" href="#http模块" aria-label="Permalink to &quot;http模块&quot;">​</a></h2><ol><li>site.py 构建了基于twisted的服务处理流程. SynapseSite,提供SynapseRequestFactory,SynapseRequestFactory创建SynapseRequest</li><li>additional_resource.py 暂时完全用不着,因为目前配置文件这部分为空</li><li>client.py SimpleHttpClient 是让synapse向其他服务器发起http请求用,比如</li></ol><ul><li>CaptchaServerHttpClient用于captcha验证</li><li>HomeServer get_simple_http_client 调用创建的用于Identity,fedoration请求等等.</li></ul><ol start="4"><li>matrixfederationclient.py 主要用于创建到fedoration的http链接,我猜应该是因为@\balice:domain.com,这里的domain.com解析比较复杂,synapse有专门的说明,在dns解析中,需要有特殊支持.</li><li>request_metrics.py 用于测量每次请求的花费</li><li>server.py主要提供JsonResource,其他各种handler都基于这个.</li></ol><h2 id="handlers模块" tabindex="-1">handlers模块 <a class="header-anchor" href="#handlers模块" aria-label="Permalink to &quot;handlers模块&quot;">​</a></h2><p>client-server ,fedoration,admin等等服务端最终的handler都在这里. 其中最复杂的莫过于sync.py中负责/sync的api</p><h3 id="变量类型映射" tabindex="-1">变量类型映射 <a class="header-anchor" href="#变量类型映射" aria-label="Permalink to &quot;变量类型映射&quot;">​</a></h3><p>txn_ctrl--&gt; _TransactionController txn AppServiceTransaction</p><h3 id="app-service-注册问题" tabindex="-1">app service 注册问题 <a class="header-anchor" href="#app-service-注册问题" aria-label="Permalink to &quot;app service 注册问题&quot;">​</a></h3><p>LoginType.APPLICATION_SERVICE 通过他可以跟踪到 application service 如何新注册用户</p><p>v1_only/register.py 1. on_POST 就算是禁止注册,也可以通过application service注册用户 2. _do_app_service 进行注册 3. appservice_register url中的access_token以及userId传进去. storage/appservice.py: 1. 如果这个access_token能够找到对应的service,则允许注册,否则不允许 我觉得这里的service应该是在配置文件homeserver.yaml app_service_config_files 2. application_service提供了一一系列验证,如果可以将此用户写入数据库中 3. 问题是如何登陆呢?这种方式也没法控制用户注册, 因为他并不会转到application service,让他们来处理这个事情.</p><h3 id="可否通过app-service注册用户呢" tabindex="-1">可否通过app service注册用户呢? <a class="header-anchor" href="#可否通过app-service注册用户呢" aria-label="Permalink to &quot;可否通过app service注册用户呢?&quot;">​</a></h3>',20),n=[s];function p(o,l,c,h,d,_){return t(),a("div",null,n)}const y=e(i,[["render",p]]);export{u as __pageData,y as default};
