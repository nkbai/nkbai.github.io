import{o as e,c as s,e as a}from"./app.a88d4154.js";const n='{"title":"opcua Rust版本学习-client","description":"","frontmatter":{"title":"opcua Rust版本学习-client","date":"2020-10-20T09:48:12.000Z","draft":false,"markup":"mmark"},"headers":[{"level":2,"title":"一个client对应多少线程/任务","slug":"一个client对应多少线程-任务"},{"level":3,"title":"session 中的任务","slug":"session-中的任务"},{"level":3,"title":"tcp transport","slug":"tcp-transport"},{"level":3,"title":"subscription相关","slug":"subscription相关"},{"level":3,"title":"主线程","slug":"主线程"},{"level":2,"title":"Server 端统计","slug":"server-端统计"},{"level":3,"title":"http server","slug":"http-server"},{"level":3,"title":"PollingAction","slug":"pollingaction"},{"level":3,"title":"tcp_transport","slug":"tcp-transport-1"},{"level":3,"title":"Server 层的task","slug":"server-层的task"},{"level":2,"title":"交叉编译","slug":"交叉编译"},{"level":3,"title":"openssl 依赖问题","slug":"openssl-依赖问题"}],"relativePath":"other/opcua-rust.md","lastUpdated":1606870544000}',r={},i=[a('<h2 id="一个client对应多少线程-任务"><a class="header-anchor" href="#一个client对应多少线程-任务" aria-hidden="true">#</a> 一个client对应多少线程/任务</h2><p>这里面有tokio 异步任务,所以只要是异步执行的,都任务是独立的. 一个client至少会对应两个独立线程(不包含tokio创建的线程).</p><h3 id="session-中的任务"><a class="header-anchor" href="#session-中的任务" aria-hidden="true">#</a> session 中的任务</h3><h4 id="async-responses"><a class="header-anchor" href="#async-responses" aria-hidden="true">#</a> async responses</h4><p>一个client对应一个session,一个session 有一个后台线程 <code> thread::spawn(move || Self::run_loop(session, Self::POLL_SLEEP_INTERVAL, rx));</code> 周期性的去从message_queue中读取async_responses.</p><ol><li>ServiceFault 错误通知</li><li>PublishResponse 订阅拉的结果,这些结果会通过<code>OnSubscriptionNotification</code> 告诉客户端使用者.</li></ol><p>这个线程的轮询周期是10ms.</p><h4 id="session-activity-task"><a class="header-anchor" href="#session-activity-task" aria-hidden="true">#</a> session_activity_task</h4><p>通过发送一个空的ReadRequest来模拟ping消息,保持和服务器的连接. 这是一个tokio任务,周期是1秒钟.</p><h3 id="tcp-transport"><a class="header-anchor" href="#tcp-transport" aria-hidden="true">#</a> tcp transport</h3><p>tcp连接处理相关.</p><h4 id="_1-总任务"><a class="header-anchor" href="#_1-总任务" aria-hidden="true">#</a> 1. 总任务</h4><p>建立连接,send hello以后就老等下面三个任务(都在<code>connection_task</code>中)完成后结束. 注意这是一个独立的线程.</p><h4 id="_2-spawn-finished-monitor-task"><a class="header-anchor" href="#_2-spawn-finished-monitor-task" aria-hidden="true">#</a> 2. spawn_finished_monitor_task</h4><p>监控连接是否结束,这个很奇怪,没有使用通知,居然是轮训模式 轮询周期是200ms</p><h4 id="_3-spawn-reading-task"><a class="header-anchor" href="#_3-spawn-reading-task" aria-hidden="true">#</a> 3. spawn_reading_task</h4><p>从tcp连接上读取服务器发送过来的消息,消息主要有三种类型:</p><ol><li>Ack 对Hello消息的确认,其他消息都是Request/Reponse?</li><li>Error</li><li>Response</li></ol><p>Server从不主动给client发消息,除了Error以外.</p><p>收到Response以后,放到message_queue的<code>responses</code>中.等待其他任务来取.</p><h4 id="_4-spawn-writing-task"><a class="header-anchor" href="#_4-spawn-writing-task" aria-hidden="true">#</a> 4. spawn_writing_task</h4><p>通过message_queue中的request_channel接受请求,然后发送给服务器.</p><h3 id="subscription相关"><a class="header-anchor" href="#subscription相关" aria-hidden="true">#</a> subscription相关</h3><p>一个client只有一个session,但是一个session可以有多个subscription,每个subscription有一个唯一的整数id.</p><h4 id="_1-timer-task"><a class="header-anchor" href="#_1-timer-task" aria-hidden="true">#</a> 1. timer_task</h4><p>周期性的向服务器发送<code>PublishRequest</code>,不管服务器有没有响应. 除非收到了服务器的ServiceFault(BadTooManyPublishRequests).</p><h3 id="主线程"><a class="header-anchor" href="#主线程" aria-hidden="true">#</a> 主线程</h3><p>send_request是一个同步的操作.</p><ol><li>通过async方式将request放入message_queue的队列中</li><li>不停的轮询message_queue的response中是否有想要的响应</li><li>拿到响应后返回.</li></ol><p>这里有一个问题,就是将request放入message_queue中会锁住session_state,但是这个数据结构非常关键. 到处都在用,是否会造成死锁? 如果一个请求迟迟发送不出去呢? 即使这时候收到了服务器端的其他publish Response消息,也是无法处理的,因为处理的过程要锁住session_state.</p><h2 id="server-端统计"><a class="header-anchor" href="#server-端统计" aria-hidden="true">#</a> Server 端统计</h2><h3 id="http-server"><a class="header-anchor" href="#http-server" aria-hidden="true">#</a> http server</h3><p>这是一个通过http接口展示server内部统计信息的工具. 比较独立,可以不用管,需要的时候才会启动.</p><h3 id="pollingaction"><a class="header-anchor" href="#pollingaction" aria-hidden="true">#</a> PollingAction</h3><p>一个定时执行函数的工具,只不过他会检查server是否在运行.</p><h3 id="tcp-transport-1"><a class="header-anchor" href="#tcp-transport-1" aria-hidden="true">#</a> tcp_transport</h3><p>和客户端通过tcp进行通信的地方, 以下任务是每一个连接都要创建的.</p><h4 id="spawn-hello-timeout-task"><a class="header-anchor" href="#spawn-hello-timeout-task" aria-hidden="true">#</a> spawn_hello_timeout_task</h4><p>检查连接建立后,是否收到hello,如果收到呢就结束这个task,否则后台一直周期性的检查.</p><ol><li>超时, 发送Message::Quit,断开连接</li><li>收到,结束.</li></ol><h4 id="spawn-subscriptions-task"><a class="header-anchor" href="#spawn-subscriptions-task" aria-hidden="true">#</a> spawn_subscriptions_task</h4><p>周期性的,这个周期取决于采样周期和订阅周期. 两个任务:</p><h5 id="收集pulish-responses"><a class="header-anchor" href="#收集pulish-responses" aria-hidden="true">#</a> 收集pulish responses</h5><ol><li>清理过期的publish requests</li><li>收集publish responses,并通过channel 发送.</li></ol><h5 id="接收publish-reponses"><a class="header-anchor" href="#接收publish-reponses" aria-hidden="true">#</a> 接收publish reponses</h5><p>收到以后通过sender发送出去</p><p>我的问题: *<strong>为什么这是两个独立的任务? 合成一个不更好么?</strong></p><h4 id="spawn-finished-monitor-task"><a class="header-anchor" href="#spawn-finished-monitor-task" aria-hidden="true">#</a> spawn_finished_monitor_task</h4><p>一个独立的任务,周期性检查server是否退出. 思路和client是完全一样的. 感觉这种周期性的任务很奇怪,也不合理.</p><h4 id="spawn-reading-loop-task"><a class="header-anchor" href="#spawn-reading-loop-task" aria-hidden="true">#</a> spawn_reading_loop_task</h4><p>读取来自客户端的消息,这里面主要有两个状态:</p><ol><li><p>WaitingHello 这个时候什么消息都不处理,只处理Hello,处理以后,才能正常处理其他消息.</p></li><li><p>ProcessMessages 处理任何消息.核心在process_chunk中.</p></li></ol><p>其他的就是如何处理错误以及结束.</p><h4 id="spawn-writing-loop-task"><a class="header-anchor" href="#spawn-writing-loop-task" aria-hidden="true">#</a> spawn_writing_loop_task</h4><p>向客户端发送消息,发送消息的请求来自以上三个task:</p><ul><li>spawn_hello_timeout_task</li><li>spawn_subscriptions_task</li><li>spawn_reading_loop_task</li></ul><ol><li>发送之前检查连接的可用性</li><li>发送之前检查消息的正确性</li><li>将要发送消息放入buffer中.</li><li>通过write_bytes_task发送出去</li><li>发送后再次检查是否需要关闭.</li></ol><p>** shutdown没有await,需要加上.</p><h3 id="server-层的task"><a class="header-anchor" href="#server-层的task" aria-hidden="true">#</a> Server 层的task</h3><h4 id="discovery-server相关"><a class="header-anchor" href="#discovery-server相关" aria-hidden="true">#</a> discovery server相关</h4><p>可以不用,暂时忽略.</p><h4 id="add-polling-action"><a class="header-anchor" href="#add-polling-action" aria-hidden="true">#</a> add_polling_action</h4><p>这是一个pub api,让调用者可以周期性的在server内部做一些事情.</p><p>但是这个只能添加,不能删除.</p><h2 id="交叉编译"><a class="header-anchor" href="#交叉编译" aria-hidden="true">#</a> 交叉编译</h2><p>针对raspberry进行交叉编译</p><div class="language-"><pre><code>sudo apt-get install gcc-arm-linux-gnueabihf\nrustup target add armv7-unknown-linux-gnueabihf     # armv7\ncargo build --target armv7-unknown-linux-gnueabihf --release \n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="cargo-config"><a class="header-anchor" href="#cargo-config" aria-hidden="true">#</a> .cargo/config</h4><div class="language-"><pre><code>[target.arm-unknown-linux-musleabihf]\nlinker = &quot;arm-linux-musleabihf-ld&quot;\n\n[target.armv7-unknown-linux-musleabihf]\nlinker = &quot;arm-linux-musleabihf-ld&quot;\n\n[target.arm-unknown-linux-gnueabihf]\nlinker = &quot;arm-linux-gnueabihf-gcc&quot;\n\n[target.armv7-unknown-linux-gnueabihf]\nlinker = &quot;arm-linux-gnueabihf-gcc&quot;\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="openssl-依赖问题"><a class="header-anchor" href="#openssl-依赖问题" aria-hidden="true">#</a> openssl 依赖问题</h3><div class="language-"><pre><code>cd /tmp\n\nwget https://www.openssl.org/source/openssl-1.0.1t.tar.gz\ntar xzf openssl-1.0.1t.tar.gz\nexport MACHINE=armv7\nexport ARCH=arm\nexport CC=arm-linux-musleabi-gcc\ncd openssl-1.0.1t &amp;&amp; ./config shared &amp;&amp; make &amp;&amp; cd -\n\nexport OPENSSL_LIB_DIR=~/openssl-1.0.1t/\nexport OPENSSL_INCLUDE_DIR=~/openssl-1.0.1t/include\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果想静态编译就要使用arm-linux-musleabi-gcc, 用arm-linux-musleabihf-gcc的话,会出现<code>-mfloat-abi=hard</code>不支持错误.</p>',72)];r.render=function(a,n,r,l,t,p){return e(),s("div",null,i)};export{n as __pageData,r as default};
